---
layout: doc
title: Multi-tenant setup
description: How to run multiple tenants within a single FusionAuth instance
---

:page-liquid:

== Overview

This guide will help you set up a multi-tenant application in FusionAuth. Tenants allow for logical separation of users, applications and other entities in FusionAuth.

TOC TODO

== Why Use Multi-Tenancy

There are many reasons why you might be interested in a multi-tenant FusionAuth instance:

* The logical separation. While you have only one FusionAuth instance to manage, users, applications, API keys, and many other configurable entities are logically distinct.
* You might be interested in building an application which you'll offer as a service, often called SaaS (Software as a Service). In this case, each different customer can be modeled as a tenant. 
* Managing different deployment environments. For instance, on one FusionAuth instance, you could run integration, user acceptance and developer environments. It's not recommended to run the production on the same instance as other environments, however.
* Managing multiple developer environments. You also might want to provide a tenant for each developer on a dedicated development server. This would allow developers free reign to add, remove and modify entities in their FusionAuth tenant, while keeping them relatively insulated from each other.
* You need different tenant level settings for clients. Examples of such settings include password rules, the issuer of JWTs, or webhook transaction levels.

FusionAuth's performant, lightweight multi-tenancy

== Multi-Tenant Concepts

XXX TODO?

To make things a bit more concrete, let's use an example. Let's talk about Pied Piper Video Chat (or PPVC for short). It will be so much better than Slack chat with patented middle out compression. This application will have multiple tenants. Every one who signs up will get a domain name like `companyx.piedpiper.com`.

Before this guide covers how to set up multi-tenancy, let's cover what can be configured at the tenant level. There are five general categories of modifiable entities in FusionAuth:

* Tenant scoped entities
* Tenant attached entities
* Application scoped entities
* Application attached entities
* Global "things"

A "scoped" entity is contained within the enclosing entity, and if the latter is deleted, the former will be as well. For instance, a user is scoped to a tenant, and if that tenant is deleted, the user will be as well. 

Scoped entities cannot be shared between multiple entities to which they are scoped. If the Pied Piper chat application needs groups for different user privileges, each tenant would have its own "Admin Group", "Moderator Group" and so on.

An "attached" entity is affiliated with an enclosing entity, but if the latter is deleted, the former will continue to exist. For instance, a signing key is associated with a tenant's JWT configuration. If that tenant is deleted, the signing key's association with the tenant is removed, but the tenant is not. 

Attached entities can be re-used between entities. For example, if the Pied Piper chat application needs to add a user privilege claim to a JWT, the same Lambda can be used.

TODO extract to share with core concepts?

=== Tenant Scoped 

Here is a list of items that are tenant scoped:

* Users
* Groups
* API Keys (optionally)
* Applications
* Entities

=== Tenant Attached 

Here is a partial list of tenant attached items:

* Email templates (some of them)
* Forms (some of them)
* Themes
* Connectors
* Consents
* User actions
* Webhooks

=== Application Scoped

Here is a list of application scoped items.

* Registrations
* Roles

Because an application is tenant scoped, the above entities are also scoped to a tenant. They cannot be used across tenants. For example, if a tenant containing the containing application is deleted, the registrations for a given application will also be deleted.

=== Application Attached

Here is a partial list of application attached things:

* Identity providers
* Email templates (some of them)
* Forms (some of them)
* Lambdas

=== Global Items

There are items global in scope. These are typically scoped under `system` in the API namespace.

* API Keys (optionally)
* Login reports?
* Logs

Additionally, there are configuration settings for CORS which are shared between all the tenants in an instance.

The administrative user interface is also shared between tenants. There is no way to grant access to the FusionAuth administrative user interface but limit the user to a single tenant. There is an https://github.com/FusionAuth/fusionauth-issues/issues/91[open issue].

If you need separation of global configuration, or if you need true physical separation due to different regulatory regimes, you can run multiple FusionAuth instances. If you need to sync configuration between them, script your changes using the API, terraform provider, or client libraries.

== Components of a Multi Tenant Setup

While every application is different, there are common components to any multi tenant application.

* The control plane application
* The data plane application
* FusionAuth tenants and applications
* Data plane application tenant determination 
* Initial and deferred tenant setup component
* The tenant object

Let's look at each of these briefly. I'll continue to use the example of the video chat application built by the Pied Piper corporation (with inside out compression, of course) to illustrate some of these concepts.

=== The Control Plane Application

When you have a multi tenant SaaS application, you need some way to manage those tenants. Unapologetically borrowing from the https://en.wikipedia.org/wiki/Control_plane[network routing analogy], you need to build a control plane application to manage user and tenant creation. This is also where you can integrate billing and general account management if you are charging for your application.

Pied Piper Video Chat has to have an application of this type, which will let users sign up for Pied Piper Video Chat for their company. They need to be able to do other things like set up the PPVC url for their company, customize it, and set up billing. But this application doesn't need to support the chatting interface. This application is essentially a tenant management portal, where users can modify settings of their tenants.

For PPVC, this will likely be a web application, but the actual implementation details don't really matter for the purposes of multitenancy.


=== The Data Plane Application

This is the application that your users want to offer to their users. For PPVC, that is the video chat application. This application will have users with roles and may have payment or other account options as well. But while there may be overlap, the features of this application aren't the same as that of the control plane appliation. For one thing, there is no need to create separate tenants in this application, and the users of the video chat application may be entirely seperate from that of the management application. 

For PPVC, this will likely be a web application, but it could also be a mobile application as well. The actual implementation details don't really matter for the purposes of this document.

Note that the control plane and data plane applications are conceptually different, but do not need to be physically different. You could, in other words, implement them in the same web application. This may make sense to do initially, because there will be database overlap between them. 

As you grow, that may change. They will probably have different SLAs, it might be ok for one of them to have more downtime than the other, and they'll have different features and release cycles. So you can think about splitting them apart at some point. But for an initial implementation, it may be simpler to build them together. That's an implementation choice for you to consider.

=== FusionAuth Tenants and Applications

For each of the web, mobile or other applications that are built, a corresponding FusionAuth entity should be created.

For example, the control plane application will have a corresponding FusionAuth tenant where the users of the control plane application will be stored. It will also have a FusionAuth application to record the configuration needed to login to that application. 

Because you are building a multi tenant application, each data plane application will have a FusionAuth tenant and a FusionAuth application. 

So, for the Pied Piper Video Chat control plane application, there'd be a tenant. Call it the PPVC tenant. This is where users of the SaaS application would sign up and configure their instance of the video chat application. 

Each time a user signed up and created a new instance, there'd also be a new data plane tenant. Let's say that an employee at Raviga signs up for PPVC. A new FusionAuth tenant will be created for Raviga, and within that tenant a new FusionAuth application. This Raviga tenant would be where all Raviga users of the PPVC would be stored. 

This configuration information must be stored somewhere. The best place is in the PPVC database. The creation of the FusionAuth configuration can, however, be automated.

=== Data Plane Application Tenant Determination 

The data plane application needs to differentiate between the different tenants. If everything is hosted at ppvc.com, there are a few ways to do so:

* The hostname: raviga.ppvc.com would point to the Raviga instance of the application. And hooli.ppvc.com would point to the Hooli instsance. This is similiar to how Slack operates.
* User choice: The user logs in and is presented with a list of data plane applications to which they can login (or transparently SSO into). In this case, you can present this option in the control plane application.
* User or request attributes: If there is some way for the system to know which data plane application is associated with the user, the user may not need to be prompted. For instance, if the system can read network or user agent attributes to determine the appropriate data plane application, it should do so. 

In many cases, a hostname is the easiest way to do this differentiation. Using this is memorable to the user, works well with internet standards like cookies, and scales well. That's the approach this guide will take.

=== Tenant Setup

When a user signs up in the control plane application and creates a new tenant, there are a number of things that need to happen.

The following configuration needs to occur:

* Hostname setup, which can be handled with DNS wildcarding
* Creation of a FusionAuth tenant and a FusionAuth application. This will allow the new data plane application to let users log in.
* Any needed configuration of the data plane application. For example, the PPVC application might allow users at a premium level to have 10 chat rooms, whereas users at the basic level could only have 2. 

Since the new tenant application isn't usable without these configuration settings, they should take place synchronously. 

There is also some optional configuration:

* Creating a user within the FusionAuth tenant for initial sign in.
* Creating any FusionAuth roles that might be applicable, such as an `admin` role.
* Customizing the theme of the FusionAuth hosted login pages with items like custom colors and logos.

Since the new tenant application is usable without these changes, they can take place asynchronously. 

=== The Tenant Object

Within your control plane application's datastore, you'll want to store metadata about the tenants. This is useful both for the users to modify their information, for the data plane application to deliver proper functionality, and for reporting as your business grows. 

This tenant object could have customization information.

Here are some attributes you might need in your tenant object if you were implementing multitenancy with FusionAuth:

* Owning user id: which user created this tenant. It could be a one to one, or one to many mapping depending on your needs.
* Hostname: the user selected hostname to which users of the PPVC chat application for an organization will go. Something like raviga.ppvc.com
* FusionAuth tenant id: the tenant created in FusionAuth during the setup.
* FusionAuth client id and client secret: these are used during the login process for the data plane application.
* Custom attributes such as a logo or background color for the hosted login pages. 
* An API key and API key id. This is useful if the control plane application needs to modify FusionAuth configuration. This API key could even be exposed to the administrators of the data plane application to, for example, write a script to pull a list of their users.

== Registration and Login Flows

Let's get more concrete. Here are is the registration flow for the control plane application. 

++++
{% plantuml source: _diagrams/docs/guides/control-plane-registration.plantuml, alt: "Registration process for the control plane application." %}
++++

Here's the login flow for a data plane application. Note that apart from the lookup of the tenant configuration by hostname, this is a pretty typical Authorization Code grant.

++++
{% plantuml source: _diagrams/docs/guides/data-plane-login.plantuml, alt: "Login process for the data plane application." %}
++++

== Building Required Components

When building a multi tenant application, you need the following components:

* Initial FusionAuth configuration of the control plane application.
* A tenant object in your database, as well as CRUD methods to manage it.
* A way to create and delete required FusionAuth configuration for the data plane applications.
* Some way for user login, registration and logout requests to be routed to the correct FusionAuth tenant.
* The callback handling for the authorization code.

Let's look at each of these. You can download, review and run a https://github.com/FusionAuth/fusionauth-example-symfony-multitenant[fully functional multi-tenant chat application].

=== Initial FusionAuth Configuration

The control plane FusionAuth application needs to be configured in FusionAuth. You can create this in its own tenant to increase isolation.
You also need to create a Key Manager API key. Navigate to [breadcrumb]#Settings -> API Keys# and create a global API key. Make sure you enable [field]#Key manager# as this will be used to mint new tenant scoped API keys.

You should enable the following:

* A redirect URL
* The authorization code grant
* Self service registration, if desired
* Roles, if desired

pic TBD

You also need to create a Key Manager API key. Navigate to [breadcrumb]#Settings -> API Keys# and create a global API key. Make sure you enable [field]#Key manager# as this will be used to mint new tenant scoped API keys.

pic TBD

And you'll want to create a separate tenant to serve as a blueprint for all newly created tenants. This is the tenant with the default settings for the data plane FusionAuth tenants. You can set things like email configuration, password complexity and other settings. Of course, you can customize these for each tenant, but having a blueprint to copy makes the initial new FusionAuth tenant setup easier.

pic TBD

Instead of running through these manually, you can also download this kickstart file and run it using link:/docs/v1/tech/installation-guide/kickstart[Kickstart]. TBD put here: https://github.com/fusionauth/fusionauth-example-kickstart

=== The Tenant Object

The tenant object lives in your application. This will serve as the storage location for all tenant related information. This includes anything your application needs, such as background color, logo, plan level, or business domain specific data. It also includes FusionAuth specific information such as API keys and OAuth configuration information.

Here's a sample tenant table definition:

[source,sql,title=Tenant script]
----
CREATE TABLE `tenant` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `hostname` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `background_color_code` varchar(6) COLLATE utf8mb4_unicode_ci NOT NULL,
  `fusion_auth_tenant_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `api_key` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `api_key_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `client_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `client_secret` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UNIQ_4E59C462A76ED395` (`user_id`),
  CONSTRAINT `FK_4E59C462A76ED395` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
----

This implementation maps each tenant to a single user, becuase `user_id` is a foreign key into the local `user` table. You could choose to allow users to create multiple tenants as well. You'll need to create a CRUD interface to create this row and populate the application specific fields, such as background color and host. 

[NOTE]
====
You could use link:advanced-registration-forms/[Advanced Registration Forms], a premium feature, to capture all the needed tenant eetup information, such as hostname, and then use a webhook to create the FusionAuth configuration and the tenant object in your application database too.
====

The hostname is worth emphasizing, since it will come up repeatedly. Remember, this guide is building a video chat application. The hostname is how the application will differentiate between different tenants. raviga.ppvc.com would point to the Raviga instance of the application. And hooli.ppvc.com would point to the Hooli instsance, similiar to how Slack operates.

You can either let the user pick the hostname (`raviga`) or assign it (`tenant123`). In either case, it will be prepended to the domain name (`ppvc.com`) for the end user. You could of course also let the user choose an entirely different host (`chat.hooli.com`) and the same principles apply.

The FusionAuth specific fields in this table are:

* `fusion_auth_tenant_id`: the UUID representing the tenant.
* `api_key`: a tenant locked API key.
* `api_key_id`: the Id of the tenant locked API key. This is useful if you want to manage this API key.
* `client_id`: the client Id of the data plane FusionAuth application. Used to direct users who are interacting with FusionAuth to the correct client.
* `client_secret`: the corresponding client secret.

You'll see how to set the FusionAuth specific fields next.

== Updating the Tenant Object With FusionAuth Configuration

Next, you need a way to create and delete required FusionAuth configuration for the data plane applications.

[NOTE]
====
You can use link:/docs/v1/tech/client-libraries/[any of the client libraries] to create FusionAuth configuration. This document happens to use PHP, but you should use whatever language suits your project.

Client libraries are used by creating JSON objects as documented by the link:/docs/v1/tech/apis/[APIs] and then calling methods named after the operations in those same document.
====

This is going to depend on your application framework and requirements. You have a couple of options for calling the FusionAuth APIs to configure the new tenant:

* In the same controller where you create the row in the tenant table, call the APIs.
* Use a queue. Put a message on the queue when a new tenant row is added, then have a listener retrieve the message and create the configuration.
* Use a pre-persist method to call the APIs before the tenant is saved.

For the example application, I used the latter method. Before the tenant information is saved to the application database, the FusionAuth APIs are called and the needed FusionAuth configuration is created. What makes sense depends on how many new tenants you expect to be created and how much configuration you need to do. 

The minimal amount of FusionAuth configuration is:

* Creating the tenant. 
* Setting up a tenant locked API key.
* Using the new tenant locked API key, create the application.
* Store off these values in your database.

Let's take a deeper look at each of these.

=== Creating the FusionAuth Tenant 

The easiest way to do this is to pull the blueprint tenant, extract unchanged configuration and then create the new tenant.

Here's some PHP code to do this:

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$client = new FusionAuthClient($fusionauthKeyManagerKey, $fusionauthBase);

$result = $client->retrieveTenant($this->blueprintTenantId);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$blueprint_tenant = $result->successResponse;

// pick off what we know we want to minimize forward compatibility issues.

$tenant_object = array();
$tenant_object["name"] = $tenant->getHostname();
$tenant_object["themeId"] = $blueprint_tenant->tenant->themeId;
$tenant_object["issuer"] = 'https://'.$tenant->getHostname().".ppvc.com";

$tenant_email_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->emailConfiguration);
$tenant_object["emailConfiguration"] = $tenant_email_configuration;

$tenant_jwt_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->jwtConfiguration);
$tenant_object["jwtConfiguration"] = $tenant_jwt_configuration;

$tenant_externalId_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->externalIdentifierConfiguration);
$tenant_object["externalIdentifierConfiguration"] = $tenant_externalId_configuration;

$tenant_request = array();
$tenant_request["tenant"] = $tenant_object;

$result = $client->createTenant('', $tenant_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
} 

$new_tenant = $result->successResponse;
return $new_tenant->tenant->id;
----

In this code, you can see that the following configuration is extracted from the blueprint tenant:

* `themeId`
* `emailConfiguration`
* `jwtConfiguration`
* `externalIdentifierConfiguration`

There are only a few things configured differently. The name of the tenant, which is set to the hostname, and the issuer, which is set to the expected host. At this point, you could also tweak any of these settings as needed. 

==== The Tenant Locked API Key

You should set up a tenant locked API key for two reasons:

* You can use it for all other configuration of this FusionAuth tenant, following the principle of least privilege.
* You can expose it to your clients to use for their own purposes, such as managing users.

You could also create two different tenant locked API keys, one which can create new API keys (a key manager) and one which could be used for internal management of the FusionAuth configuration. Then, if customers needed API keys to do certain tasks such as access user data, you could issue a limited permissions key.

Here's code to create the tenant scoped API key:

[source,php]
----
$apikey_object = array();
$apikey_object["metaData"]["attributes"]["description"] = "API key for ".$hostname;
$apikey_object["tenantId"] = $fusionauth_tenant_id;

$apikey_request = array();
$apikey_request["apiKey"] = $apikey_object;

$result = $client->createAPIKey('', $apikey_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$apikey = $result->successResponse;

return [$apikey->apiKey->id, $apikey->apiKey->key];
----

You need to store this key in your application's database. Both the key string and the Id are stored. The key string can be used to make other API calls. The API key id is used to manage the key in the future, if needed.

The next thing you should do after creating the API key is create a new FusionAuth client with the limited key.

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$client = null;
$client = new FusionAuthClient($fusionauthTenantLockedApiKey, $fusionauthBase);
----

Then, you want to create the application. Let's look at that next.

==== Creating a FusionAuth Application

[source,php]
----
$saasRootDomain = '.ppvc.com'; // or pull from config
$ppvc_app_base = "https://".$hostname.$saasRootDomain;

$application_object = array();
$application_object["name"] = "Default application for ".$hostname;

$application_oauthconfiguration = array();
$application_oauthconfiguration["authorizedRedirectURLs"] = [$ppvc_app_base."/login/callback"];
$application_oauthconfiguration["enabledGrants"] = ["authorization_code"];
$application_oauthconfiguration["logoutURL"] = $ppvc_app_base;
$application_object["oauthConfiguration"] = $application_oauthconfiguration;

$application_registrationconfiguration = array();
$application_registrationconfiguration["enabled"] = true;
$application_object["registrationConfiguration"] = $application_registrationconfiguration;

$application_request = array();
$application_request["application"] = $application_object;

$result = $client->createApplication('', $application_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$application = $result->successResponse;

return [$application->application->id, $application->application->oauthConfiguration->clientSecret];
----

Here you are creating an application. You can see that there is an application base url, something like `https://raviga.ppvc.com`, which is built. Next you need to configure various parts of the OAuth config.

First, configure the OAuth portion of the application. 

* Enable the authorization code grant with the `enabledGrants` field. (Here's an link:/docs/v1/tech/oauth/#example-authorization-code-grant[example authorization code grant]).
* Set up the `logoutURL`. This is where FusionAuth will send the user after they have logged out.
* Set up the `authorizedRedirectURLs`. These are URLs to which FusionAuth will send the authorization code. The controller here should exchange that code for a token. At this point the user is logged in.

Remember, this is going to represent `raviga.ppvc.com`, and so the Raviga users will need to be created in this tenant in some fashion. You could:

* Allow users to sign in with a social provider.
* Create users via the API through an automated process.
* Allow users to sign in with a enterprise provider such as an OAuth or SAML compliant identity provider.
* Let users sign up for an account with basic or advanced registration forms.

Here, self service registration is enabled for this application. Any of these will work, though. If you choose a different one, you'd use different API calls to configure the application or other parts of FusionAuth. For instance, if you wanted to allow anyone to sign in with Google, you'd have to create an identity provider in the <<Initial FusionAuth Configuration>>, and then assigned the identity provider to the created FusionAuth application.

Finally you are going to need the application's Id, which corresponds to the OAuth client Id, and the application's client secret, which corresponds to the OAuth client secret. These values should be stored in your application's database, just like you stored the API key.

==== Other FusionAuth Configuration

The above is all that is required to let users log in to and register for the new FusionAuth tenant. Other FusionAuth actions you might want to take:

* Add a user or set of users and register the for the new application.
* Set up roles.
* Set up groups.
* Assign users to groups and roles.
* Set up specific FusionAuth API keys with limited permissions for certain purposes.

== Routing Requests to the Correct Tenant

As mentioned in <<Data Plane Application Tenant Determination>>, you need to have some way to map from a request to a FusionAuth application. Each FusionAuth application lives in one and only one tenant, so mapping to the application is an easy way to map to a tenant. There may be situations where you want to map directly to the tenant and then perhaps offer a list of applications to sign in to, but that is beyond the scope of this guide.

Typically the hostname is used to determine the tenant. So `raviga.ppvc.com` points to the Raviga tenant and `hooli.ppvc.com` points to the Hooli tenant. 

=== Configure DNS and Your Web Server to Handle Wildcard Domains

You need to configure your DNS and web application web server to send all requests to a host ending in `.ppvc.com` to your web application. How to do so varies depending on your DNS provider and web application server.

Consult your DNS provider documentation on how to point a wildcard DNS entry to a given host. 

If you are developing locally, you can add multiple hostnames to your `/etc/hosts` file. 

[source]
----
127.0.0.1       localhost app.ppvc.com raviga.ppvc.com hooli.ppvc.com
----

Here's an example Apache configuration to send traffic for multiple ppvc.com addresses to a given web server. Consult your web server documentation for appropriate configuration.

[source]
----
<VirtualHost *:443>
  ServerName app.ppvc.com
  ServerAlias *.ppvc.com

  ProxyPreserveHost on
  ProxyPass / http://localhost:8000/ retry=1
  ProxyPassReverse / http://localhost:8000/ retry=1
</VirtualHost>
----

=== Look Up the OAuth Configuration Based On the Hostname

Once the request is recieved by your web application, you previously stored the hostname and the client Id/secret in the tenant table in your database. When a request comes in for a login (to `https://raviga.ppvc.com/login`, for example), you can map from the hostname (`raviga`) to the appropriate client Id. Here is sample code:

[source,php]
----
$client_id = ''; 
$client_secret = '';
    
if ($this->isControlPlaneHost($host)) { 
  $client_id = $this->controlPlaneClientId;
  $client_secret = $this->controlPlaneClientSecret;
} else { 
  $hostname = $this->hostname($host); // converts from raviga.ppvc.com to raviga
  $repository = $this->entityManager->getRepository(Tenant::class);
  $tenant = $repository->findOneBy(array('hostname'=>$hostname));
  if ($tenant) { 
    $client_id = $tenant->getApplicationId();
    $client_secret = $tenant->getClientSecret();
  } else { 
    // throw an error, this is not a valid hostname. Doing so will allow an attacker to enumerate your supported hostnames, however.
  }
} 
return [$client_id, $client_secret];
----

There are a couple of items worth pointing out here.

First, the code checks to see if the host matches the control plane application. Remember, in this particular multi-tenant application, the web application responds to all requests for any users, both those creating video chat tenants and the users of those video chat tenants. The OAuth config for the former is static and was created in the <<Initial FusionAuth Configuration>>. The latter is dynamic, stored in the database and was created in <<Creating a FusionAuth Application>>.

For the latter situation, you look up the tenant object by the hostname and return the client Id and client secret.

This is then used to create the login, logout and registration links. These links can be placed in your application's navigation or any other location where the user might want to login and log out.

Let's look at those next.

=== Create the Links

The sample application leverages an open source library for managing and creating OAuth URLs. You'll need to provide the `client_id`. This library handles setting the `state` parameter and other niceties. If your web application framework or language has this type of library, using it is highly recommended. 

However the login link generating function can be as simple as this:

[source,php]
----
$redirectURI = '...'; // discussed below.
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
return $fusionauthBase . '/oauth2/authorize?client_id='.$client_id.'&redirect_uri='.$redirectURI.'&response_type=code'
---

The registration URL is the same format, but uses the path `/oauth2/register` instead of `/oauth2/authorize`.

[source,php]
----
$redirectURI = '...'; // discussed below.
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
return $fusionauthBase . '/oauth2/register?client_id='.$client_id.'&redirect_uri='.$redirectURI.'&response_type=code'
---

Finally, the logout URL. Because we configured the `logoutURL` of the FusionAuth application, FusionAuth will redirect the user to the proper location after logging the user out of FusionAuth. All you need to provide is the `clientId`.

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$fusionauthBase.'/oauth2/logout?client_id='.$clientId;
----

You can then use these functions whenever you present a login, registration or logout link. 

== Handling OAuth Callbacks 

The final piece is handling the OAuth callbacks. You may recall that in the <<Creating a FusionAuth Application>> section, you configured a FusionAuth application with a given `authorizedRedirectURLs` value. It was something like: `https://raviga.ppvc.com/login/callback`.

You must create a part of your web application that responds to that path. It will need to do the following things:

* Determine what the correct tenant is so you can use the correct client Id and client secret.
* Exchange the authorization code for a token.
* Log the user into your web application.

Let's look at each of these.

=== Determine the Tenant's OAuth Configuration

This is exactly the same as the <<Look Up the OAuth Configuration Based On the Hostname>> step.

=== Exchange the Authorization Code

You should leverage the OAuth libraries available. You can also use the FusionAuth client library as well:

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$noApiKeyNeeded = '';
$client = new FusionAuthClient($noApiKeyNeeded, $fusionauthBase);

$result = $client->exchangeOAuthCodeForAccessToken($code, $client_id, $client_secret, $redirect_uri)
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$oauthResult = $result->successResponse;

$token = $oauthResult->access_token;
----

=== Log the User In

At this point you have an access token. You can examine it to see if the user is authorized for this FusionAuth application. You can also examine the roles assigned to this user in FusionAuth. 

You should create a login session in your application. This is framework specific, so is left as an exercise for the reader.

You can also create or update a local user record. This can be useful if there are other parts of the application which will be tied to a user. For example, if you are going to store video chat metadata, you will want to tie the chat to each user. If you wanted to let users send video messages, you'd want to have a `messages` table referencing each user id. You can use the FusionAuth UUID provided, or you could use an internal id. Your user should store the FusionAuth user Id in the web application database. This will make correlating the two sets of data easier.

After this you can redirect to the chat page for the data plane applications or a user profile page for the control plane applicatoin. Again, you can distinguish between these by checking the hostname.

== Gotchas

After you've set this up, there's still a fair bit more to do to build a professional grade multi-tenant SaaS application, but you have a solid foundation.

Other items to consider:

* Should you split out the code for control plane application (which lets users create tenant applications) and the data plane applications (the application which actually lets users use the SaaS functionality, such as a pied piper vide chat)? Both of these applications will be using the `tenant` object (the control plane to write it, the data plane to read it), so you'll need to either share a database or have some other way of syncing up that data. If you use the same web application, you'll want to gate which controllers are available based on whether the control plane or a data plane application is executing. 

* Email addresses for your local user object. Often times a web framework will want a unique email address for the local user record. But FusionAuth tenants have a separate userspace. I can sign up for raviga.ppvc.com and hooli.ppvc.com with the same richard@fusionauth.io address. To address this, you can either use a compound key for the email address, or you can prepend the FusionAuth user id which is guaranteed to be unique, or you could set up some other unique string. This means that when you want to present the user's email address, either to them or for reporting or marketing purposes, you'll need to retrieve it from FusionAuth.

* You should handle tenant deletion as well as creation. When a user deletes their account, you'll want to make a call to FusionAuth to remove the FusionAuth configuration as well. You are able to do that with a call to the link:/docs/v1/tech/apis/tenants/#delete-a-tenant[Delete Tenant API].

== API Calls

If you are not using a tenant scoped API key, you should provide a tenant Id in all of your API calls. There are cases where the tenant can be inferred from another identifier (such as when you provide an application Id) but there are other times where it cannot (such as when you are creating a user). It's better to be consistent.

Throughout the API documentation, you'll see sections like this which will specify when the header should be used.

include::docs/v1/tech/apis/_x-fusionauth-tenant-id-header-create-operation.adoc[]


== Limits

The main limits on tenants in FusionAuth are resources of the underlying server. The tenants are lightweight, but do take some resources. There are FusionAuth instances supporting thousands of FusionAuth tenants. At this scale the FusionAuth administrative user interface runs into some issues, so use one of the link:/docs/v1/tech/client-libraries/[client libraries] to manage the tenants and applications. There's a https://github.com/FusionAuth/fusionauth-issues/issues/374[GitHub issue] to resolve these limits in the administrative user interface.

Another current limitation of FusionAuth with respect to tenants is the ability to limit users who log into the adminstrative user interface to a single tenant. This is not currently supported. There's a https://github.com/fusionauth/fusionauth-issues/issues/91[GitHub issue] to add that feature.

Login records, audit logs and other log files are not separated by tenant. You may be able to query based on tenant or application Ids, but if you need true isolation of log files, you should run separate instances. There's https://github.com/FusionAuth/fusionauth-issues/issues/922[GitHub issue] to address this.

Applications and other tenant scoped entities cannot be shared across tenants. If you need to keep such entities in sync, you can write scripts to sync up the configuration of multiple applications across tenants. For users, you may be able to have users federate to an external identity provider, and enable that provider for applications across tenants. This will allow your external identity provider to be the system of record for your users.

The default tenant, in which the FusionAuth application resides, cannot be removed.


== QUESTIONS TBD

is it multi tenant or multitenant or multi-tenant?
A: it is multi-tenant see https://fusionauth.io/features/architecture/

ppvc.com? piedpipervideochat.com (register the latter)

https://github.com/fusionauth/fusionauth-issues/issues/91

diagram of applications?

TBD
deletion of tenants and api keys
async configuration setup
the local user table
unique email addresses
mapping to users in your application
navigation
single web app or multiple apps

webapp vs fusionauth app? define at beginning

for fusionauth cloud
no, you just send the client id, and we know which tenant to holds that client id
