---
layout: doc
title: Multi-tenant setup
description: How to run multiple tenants within a single FusionAuth instance
---

:page-liquid:

== Overview

This guide will help you set up a multi-tenant application in FusionAuth. Tenants allow for logical separation of users, applications and other objects in FusionAuth.

TOC TODO

== Why Use Multi-Tenancy

There are many reasons why you might be interested in a multi-tenant FusionAuth instance:

* The logical separation. While you have only one FusionAuth instance to manage, users, applications, API keys, and many other configurable objects are logically distinct.
* You might be interested in building an application which you'll offer as a service, often called SaaS (Software as a Service). In this case, each different customer can be modeled as a tenant. 
* Managing different deployment environments. For instance, on one FusionAuth instance, you could run integration, user acceptance and developer environments. It's not recommended to run the production on the same instance as other environments, however.
* Managing multiple developer environments. You also might want to provide a tenant for each developer on a dedicated development server. This would allow developers free reign to add, remove and modify objects in their FusionAuth tenant, while keeping them relatively insulated from each other.
* You need different tenant level settings for clients. Examples of such settings include password rules, the issuer of JWTs, or webhook transaction levels.

FusionAuth's performant, lightweight multi-tenancy can help with any of these scenarios.

== Levels of Isolation
There are two different kinds of isolation, physical and logical.

With physical isolation, for each tenant, you run a separate web server, database and other components (such as FusionAuth). You run the same codebase (or perhaps different versions of it). The codebase doesn't need to know about the different tenants.

The strengths of physical separation include:

* Each tenant can live in different geographies, which may be required for compliance or data sovereignty.
* Downtime for one tenant doesn't affect others.
* There is no possiblility intermixing of user data.
* Clients can live on different versions of your software and upgrades can be managed by them.

However, there are some downsides:

* Deployment becomes more difficult, as you need to ship artifacts to N different servers.
* It is more expensive because servers scale linearly with tenants.
* Rollup reporting or any other cross-tenant operation becomes a series of network calls.

The other option, which is far more common, is logical isolation. With this architecture, you have the same web server (sending traffic to different tenants based on hostname or some other attribute) with the same database. You typically have a `tenant` table and a `tenant_id` foreign key in almost every table. Your codebase knows about tenants.

The logical approach has the following benefits:

* Operations are much simpler; it's one application for you to manage, even though it looks to users like many applications.
* Typically it will be less expensive. Even if you need a bigger server to handle multiple tenants, the price won't scale linearly with the number of tenants.
* Cross tenant operations such as reporting are a database query rather than a script and network requests.

There are issues with this approach as well:

* It is more difficult, to have tenants on different versions. You can do this with feature flags or other custom coding; check out how https://stripe.com/blog/api-versioning[Stripe versions their APIs] for an example.
* One tenant's traffic can affect other tenants; this is also known as the noisy neighbor problem.
* Hosting data in different geographies becomes complex.

This guide will be discussing logical isolation of tenants. If you need physical isolation with FusionAuth, run different instances. You can also link:/learn/expert-advice/identity-basics/multi-tenancy-vs-single-tenant-idaas-solutions/[read this article for more information]. 

XXX TBD
== The PiedPiper Video Chat Application

To make things a bit more concrete, let's use an example. Suppose you wanted to build a Pied Piper Video Chat (or PPVC for short) SaaS application. Similar to Slack, but with a patented middle out compression algorithm. This application will have support multiple different, entirely distinct groups of users. Each user who signs up picks their own hostname, which sets up an application that can be logged into by others. 

The PPVC will charge each instance a rate of $7/user/month. The creator of the PPVC application will be able to pic a hostname and a display background color. If someone from Hooli joins, they'll have `hooli.piedpipervideochat.com`, for example. Slack uses hostnames to distinguish between differente tenants, and PPVC will as well.


== Multi-Tenant Concepts

However, before this guide covers how to set up a multi-tenant application with FusionAuth, let's cover what can be configured at the The FusionAuth tenant level. There are five general categories of modifiable objects in FusionAuth:

* Tenant scoped objects
* Tenant attached objects
* Application scoped objects
* Application attached objects
* Global objects

A "scoped" object is contained within the enclosing configurable object. If the latter is deleted, the former will be as well. For instance, both users and groups are scoped to a tenant, and when that tenant is deleted, the enclosed users and groups are too. Scoped objects cannot be shared between multiple configuration objects to which they are scoped. If the PPVC application has groups for different user privileges, each tenant needs to have its own group. For example, an "Admin Group" or "Moderator Group" would have to be created in each tenant.

An "attached" object, on the other hand, is linked to a different object, but if the latter is deleted, the former still exists. For instance, a signing key, created by using [breadcrumb]#Settings->Key Master#, can be associated with a tenant. When that tenant is deleted, the association is removed, but the signing key remains in the system. 

Attached objects can be shared. For example, the PPVC can use the same signing key between the `hooli.piedpipervideochat.com` and the `raviga.piedpipervideochat.com` tenant configurations. In some cases attached objects support overriding configuration for different behavior.

TBD extract to share with core concepts?

Let's examine each of the above categories.

=== Tenant Scoped 

Here is a partial list of tenant scoped objects:

* Users
* Groups
* API Keys (optionally)
* Applications
* Entities

=== Tenant Attached 

Here is a partial list of tenant attached objects:

* Email templates (some of them)
* Forms (some of them)
* Themes
* Connectors
* Consents
* User actions
* Webhooks

=== Application Scoped

Here is a partial list of application scoped objects:

* Registrations
* Roles

Since an application is tenant scoped, the above entities are also tenant scoped and cannot be used between different FusionAuth tenants. For example, if an application has an "admin" role, when the tenant containing the application is deleted, the "admin" role is as well.

=== Application Attached

Here is a partial list of application attached objects:

* Identity providers
* Email templates (some of them)
* Forms (some of them)
* Lambdas

=== Global Objects

There a few objects which are globally available. These are typically available under the `system` path in the API namespace.

* API Keys (optionally)
* Login reports
* Logs
* CORS settings

If you need separation of global configuration, or if you need true physical separation due to different regulatory regimes, run multiple FusionAuth instances. If you need to sync configuration between them, script your changes using the API, terraform provider, or client libraries.

== Components of a Multi-Tenant Setup

While FusionAuth multi-tenancy can help with many different scenarios, as mentioned above, this section will focus on building out the Pied Piper Video Chat SaaS application.

Unapologetically borrowing from https://en.wikipedia.org/wiki/Control_plane[network routing], you need to build a control plane application to manage user and tenant creation. This is also where you can integrate billing and general account management if you are charging for your application. Each application actually providing the video chat functionality will be called a data plane application. Here are common components for a multi-tenant application of this type:

* The control plane application
* The data plane application
* FusionAuth tenants and applications
* Data plane application tenant determination 
* Initial and deferred tenant setup components
* The tenant object

Let's look at each of these briefly. 

=== The Control Plane Application

When you have a multi tenant SaaS application, you need some way to manage those tenants. PPVC must have a web or mobile application where users can sign up for Pied Piper Video Chat for their company. The users may be able to do other tasks, like set up the PPVC hostname, customize the look and feel, and set up billing. PPVC needs to charge that $7/user/month fee. But this control plane application doesn't support video chat itself. The control plane application is a tenant management portal.

For PPVC, this will likely be a web application, but the actual implementation details matter much for the purposes of illustrating multi-tenancy.

=== The Data Plane Applications

Data plane applications offer functionality to PPVC's users users. So Hooli employees will log into `hooli.piedpipervideochat.com` to chat amongst themselves, and Raviga employees will do the same in the `raviga.piedpipervideochat.com` application. Within each data plane application, users can have roles and other accounts options such as payment or language preferences. 

The features of this application aren't the same as that of the control plane application. Tenant management is not part of this application. There may be no overlap in the users of this application and the control plane application either. 

For PPVC, the data plane application will likely be a web application, but it could also be an API used by a mobile application as well. The actual implementation details don't really matter for the purposes of this guide.

==== Should You Separate the Control Plane and Data Plane Applications?

The control plane and data plane applications are conceptually different, but do not need to be physically distinct. You could, in other words, implement them within the same web application. 

Doing so may make sense initially. There will be database overlap between them and it may be easier to operate a single application than to create two distinct web or mobile applications.

As you grow, you may want to split these apart. They will probably have different SLAs, and they'll have different features and release cycles. For an initial implementation, it will be simpler to build them as a single deployment artifact, and that's what this guide will do.

=== FusionAuth Tenants and Applications

For each of the web, mobile or other applications that are built, corresponding FusionAuth configuration objects need to be created. The control plane application will have a corresponding FusionAuth tenant where the users of the control plane application will be stored. It will also have a FusionAuth application object which contains application specific settings, such as whether a user can self register. Each data plane application will also have a FusionAuth tenant and a FusionAuth application. 

For the PPVC control plane web application, a FusionAuth tenant object and FusionAuth application object must be created. Each time a user signs up and creates a new PPVC host, there'd also be a new data plane tenant. (This is similar to how Slack works--I can create a `dan1234` Slack tenant and someone else can create a `jen1234` Slack tenant.) If an employee at Raviga signs up for PPVC, a new FusionAuth tenant object will be created for Raviga, and within that tenant a new FusionAuth application object. This Raviga tenant would be where all users of the Raviga PPVC application are stored. 

The mapping between the data plane application configuration and the corresponding FusionAuth tenant and application objects must be stored somewhere. In this example, each data plane application has a hostname and background color, as well as FusionAuth configuration information. This additional metadata should be stored in the application database. This will be looked at more deeply in <<The Tenant Object>> section.

=== Data Plane Application Tenant Determination 

The data plane web application needs to differentiate between the different tenants. If the code is hosted at piedpipervideochat.com, there are a few ways to send users to the appropriate tenant.

* The hostname: `raviga.piedpipervideochat.com` points to the Raviga instance of the application. `hooli.piedpipervideochat.com` point to the Hooli instance. As mentioned above, this is similiar to how Slack operates.
* User choice: A user logs in and is presented with a list of data plane applications to which they can login (or transparently SSO into). In this case, you can present this option in the control plane application. This requires syncing user data between the different tenants.
* User or request attributes: If there is an attibute of the client or incoming request which can indicate the correct tenant, that can be used to route the user to the correct location. For instance, if the system can read network information or user agent attributes to determine the appropriate data plane application, it should do so. 

In many cases, a distinct hostname is the easiest way to differentiate. This is memorable to the user, works well with internet standards like cookies, and scales well. That's the approach this guide will take.

=== Tenant Setup

When a user signs up in the control plane application, they will provide some information. They'll also need to create a new tenant object in the application database. In addition, there is some other configuration that needs to occur.

* Hostname setup. This can be handled with DNS wildcarding. You want `raviga.piedpipervideochat.com` to be pointing to your web application.
* The FusionAuth tenant and a FusionAuth application must be created and configured with values like the redirect URLs. These objects allow the new data plane application to log users in.
* Creating any FusionAuth roles that might be applicable, such as an `admin` role.
* Customizing the theme of the FusionAuth hosted login pages with items like custom colors and logos.
* Possibly creating an initial user in the FusionAuth tenant.
* Any needed metadata of the data plane application not modifiable by the end user. For example, the PPVC application might allow users at a premium level to have ten chat rooms, whereas users at the basic level could only have two. 

Since the application is not useable for the new tenant without these configuration settings, this configuration should take place at the moment of signup, or the user should be notified both that the application is being created and when the creation is done.

There may be other optional configuration that needs to occur, such as loading a list of users. If needed, that can be performed asynchronously.

=== The Tenant Object

Within your control plane application's database, store metadata about each tenant in a table. This metadata:

* Allows your users to customize their application without your intervention
* Lets the data plane application deliver proper functionality. The `raviga` tenant might be on a premium plan and be allowed ten chat rooms, whereas the `hooli` tenant might be on a basic plan and have a lower limit.
* Can be used for reporting as your business grows. 

Some attributes you might need in your tenant object when implementing multitenancy with FusionAuth:

* Owning user: which user created this tenant. Depending on your business model, there could be a one to one or one to many mapping between tenants in your control plane application database and users in the application.
* Hostname: a hostname to which users of the PPVC chat application for an organization will go. Something like `raviga.piedpipervideochat.com` or `raviga` if you will always append the domain name.
* FusionAuth tenant Id: the tenant created in FusionAuth during setup.
* FusionAuth Client Id and Client Secret: these are used by people logging into the data plane application.
* Customization attributes such as a logo or background color for the hosted login pages. 
* Internal attributes about the tenant application, such as the plan level. 
* A tenant scoped API key and API key id. When the control plane application needs to modify FusionAuth configuration, it can use this API key. This API key could also be displayed to the administrators of the data plane application. Doing so will allow them to automate interactions with their users FusionAuth. They could, for example, write a script to pull a list of their users.

== Registration and Login Flows

Let's get more concrete and continue to build out PPVC. You may want to allow users to self register for the control plane application and have the tenant setup be automated. In this case, the below diagram outlines the registration flow:

++++
{% plantuml source: _diagrams/docs/guides/control-plane-registration.plantuml, alt: "Registration process for the control plane application." %}
++++

Here's the login flow for a data plane application. This would happen after a user had registered in the control plane application and a tenant such as `raviga.piedpipervideochat.com` had been created and configured. Apart from the lookup of the tenant OAuth configuration by hostname (the Client Id and Client Secret), this is a typical Authorization Code grant.

++++
{% plantuml source: _diagrams/docs/guides/data-plane-login.plantuml, alt: "Login process for the data plane application." %}
++++

== Setting Up the Multi-Tenant System

Next, let's cover the required components for a multi-tenant SaaS application that are specific to using an external identity provider like FusionAuth. FusionAuth will be used as the user database for both the control plane and all data plane applications. Here are the tasks:

* Initial FusionAuth configuration of the control plane application.
* Creating a tenant table in your database, an object in your application, and CRUD methods to manage it.
* A way to create, modify, and delete FusionAuth configuration for each data plane application.
* Building the URLs to allow user login, registration and logout requests to be routed to the correct FusionAuth tenant.
* The callback handling for the Authorization Code grant.

Let's look at each of these from the perspective of the chat application discussed above. If you'd prefer, you can download, review and run a https://github.com/FusionAuth/fusionauth-example-symfony-multitenant[fully functional multi-tenant chat application] (video chat functionality not included).

=== Initial FusionAuth Configuration

The control plane FusionAuth application needs to be configured in FusionAuth. Create this in its own tenant to increase isolation. You should configure the following on the application:

* An authorized redirect URL. 
* The Authorization Code grant
* Self service registration, if desired.
* Roles, if desired.

image::guides/multi-tenant/setting-up-the-control-plane-application.png[Setting up the control plane application in FusionAuth.,width=1200]

Below, basic self service registration is enabled. Doing this will allow a user to sign up for the control plane application themselves. If you do not enable this, you'll have to create the users in some other fashion using the link:/docs/v1/tech/apis/users/[User API].

image::guides/multi-tenant/allowing-self-service-registration-on-the-control-plane-application.png[Allow registration on the control plane application in FusionAuth.,width=1200]

You also need to create a Key Manager API key. Navigate to [breadcrumb]#Settings -> API Keys# and create a global API key. Make sure you enable [field]#Key manager# as this will be used to mint new tenant scoped API keys.

image::guides/multi-tenant/creating-key-manager-api-key.png[Creating a key manager API key.,width=1200]

Finally, create a separate tenant to serve as a blueprint tenant. This tenant will provide the default settings for the data plane FusionAuth tenants. Configure the email server, password complexity and other settings. Of course, you may customize these for each tenant, but having a blueprint tenant to copy makes the initial data plane tenant setup easier.

image::guides/multi-tenant/adding-blueprint-tenant.png[Creating a blueprint tenant.,width=1200]

Instead of doing all of these manually, you may also download https://github.com/FusionAuth/fusionauth-example-kickstart/blob/master/example-apps/multi-tenant-control-plane-setup.json[a kickstart file], customize it, and run it using link:/docs/v1/tech/installation-guide/kickstart[Kickstart]. 

=== Defining The Tenant Object

The tenant object exists in your application. As outlined in <<The Tenant Object>>, this entity stores all tenant related information, whether for FusionAuth or application specific information. Here's a sample tenant table definition:

[source,sql,title=Tenant script]
----
CREATE TABLE `tenant` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `hostname` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `background_color_code` varchar(6) COLLATE utf8mb4_unicode_ci NOT NULL,
  `fusion_auth_tenant_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `api_key` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `api_key_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `client_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `client_secret` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UNIQ_4E59C462A76ED395` (`user_id`),
  CONSTRAINT `FK_4E59C462A76ED395` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
----

This implementation maps each tenant to a single user, becuase `user_id` is a foreign key into the local `user` table. As mentioned above, you could choose to allow users to create multiple tenants. 

You'll need to create a user interface interface to create this data as well populate the application specific fields like the background color and host. 

[NOTE]
====
You could use link:advanced-registration-forms/[Advanced Registration Forms], a premium feature, to capture tenant setup information, such as hostname on user registration. Then you could use a webhook to create the FusionAuth configuration and the tenant object in your application database too. 
====

The `hostname` is an important attribute which will repeatedly be used in the multi-tenant application. This guide is building the PPVC video chat application. The `hostname` is how the code differentiates between different tenants. `raviga.piedpipervideochat.com` points to the Raviga instance of the application. Similarly, `hooli.piedpipervideochat.com` points to the Hooli instance.

You may either let the user pick the application hostname (such as `raviga`) or assign it (`tenant123`). In either case, the `hostname` will be prepended to the domain name (`piedpipervideochat.com`) for the end user. You could of course also let the user choose an entirely different host (`chat.hooli.com`). That is a great premium feature, but requires more setup, so this guide will foruc on the hostname option.

The FusionAuth specific fields in the above table are:

* `fusion_auth_tenant_id`: the UUID representing the tenant.
* `api_key`: a tenant locked API key.
* `api_key_id`: the Id of the tenant locked API key. This allows you to manage this API key.
* `client_id`: the Client Id of the data plane FusionAuth application. 
* `client_secret`: the corresponding Client Secret.

Let's discuss how to obtain the FusionAuth configuration values and update the tenant row in your web application next.

== Updating the Tenant Object With FusionAuth Configuration

To keep FusionAuth and your application in sync, you need to be able to create and delete required FusionAuth configuration for the data plane applications, as they are created and removed.

[NOTE]
====
You can use link:/docs/v1/tech/client-libraries/[any of the client libraries] to create FusionAuth configuration. This document happens to use PHP, but use whatever language your project is using.

You can manipulate FusionAuth with the client libraries by creating JSON objects as documented by the link:/docs/v1/tech/apis/[APIs] and then calling the operation in the client library.
====

How you do this depends on your application framework and requirements. Options for calling the FusionAuth APIs to configure the new tenant include:

* In the same controller where you create the row in the tenant table, call the APIs and wait for the values to return.
* Use a queue. Put a message on the queue when a new tenant row is added, then have a listener retrieve the message and create the configuration.
* Use a pre-persist method to call the APIs before the tenant is saved.

For the example application, the latter method is used. Before the tenant information is saved to the application database, the FusionAuth APIs are called and the FusionAuth configuration objects are created. However, what makes sense depends on how many new tenants you expect to be created and how much configuration you need to do; if large numbers of users were being imported, asynchronous execution would work better. 

The minimal amount of FusionAuth configuration required:

* A tenant based on the blueprint tenant set up initially.
* A tenant locked API key.
* An application.

After these are created, the generated configuration values should be stored in the data plane applications tenant object for future reference. Let's take a deeper look at each of these.

==== Creating the FusionAuth Tenant 

The easiest way to do this is to pull the blueprint tenant, extract the default configuration and then create the new tenant. 

Here's example PHP code to do so:

[source,php]
----
$fusionauthBase = 'http://login.piedpipervideochat.com/'; // or pull from config
$client = new FusionAuthClient($fusionauthKeyManagerKey, $fusionauthBase);

$result = $client->retrieveTenant($this->blueprintTenantId);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$blueprint_tenant = $result->successResponse;

// pick off what we know we want to minimize forward compatibility issues.

$tenant_object = array();
$tenant_object["name"] = $tenant->getHostname();
$tenant_object["themeId"] = $blueprint_tenant->tenant->themeId;
$tenant_object["issuer"] = 'https://'.$tenant->getHostname().".ppvc.com";

$tenant_email_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->emailConfiguration);
$tenant_object["emailConfiguration"] = $tenant_email_configuration;

$tenant_jwt_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->jwtConfiguration);
$tenant_object["jwtConfiguration"] = $tenant_jwt_configuration;

$tenant_externalId_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->externalIdentifierConfiguration);
$tenant_object["externalIdentifierConfiguration"] = $tenant_externalId_configuration;

$tenant_request = array();
$tenant_request["tenant"] = $tenant_object;

$result = $client->createTenant('', $tenant_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
} 

$new_tenant = $result->successResponse;
return $new_tenant->tenant->id;
----

In this code, you can see that the following configuration is extracted from the blueprint tenant:

* `themeId`
* `emailConfiguration`
* `jwtConfiguration`
* `externalIdentifierConfiguration`

For this scenario, there are only a few values which differ between the new data plane tenant and the blueprint tenant: 

* The name of the tenant, which is set to the hostname.
* The issuer, which is set to the expected host. 

You could also tweak any other tenant settings as needed. For example, if your tenants had different password complexity rules, setting them when the FusionAuth tenant object is created would ensure they were consistently applied. Don't forget to store the FusionAuth tenant Id in your application's database in the `tenant` table.

Next, let's create an API key.

==== The Tenant Locked API Key

You should set up a tenant locked API key for two reasons:

* You can use the new key for all other configuration of this FusionAuth tenant. This follows the principle of least privilege and ensures you won't accidentally affect any other tenants.
* You can display it to your clients. They can then write scripts against FusionAuth for their own purposes, such as managing users. This is a low-cost value add that will increase the stickiness of your application.

Here's code to create the tenant scoped API key:

[source,php]
----
$apikey_object = array();
$apikey_object["metaData"]["attributes"]["description"] = "API key for ".$hostname;
$apikey_object["tenantId"] = $fusionauth_tenant_id;

$apikey_request = array();
$apikey_request["apiKey"] = $apikey_object;

$result = $client->createAPIKey('', $apikey_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$apikey = $result->successResponse;

return [$apikey->apiKey->id, $apikey->apiKey->key];
----

Store this key in your application's database in the tenant row. Both the key and the key Id must be stored. The key can be used to make other API calls. The API key Id can be used to modify the key later. 

The next action after creating the tenant scoped API key is create a new FusionAuth client that uses this less powerful key:

[source,php]
----
$fusionauthTenantLockedApiKey = '...'; // returned from the previous code block
$fusionauthBase = 'http://login.piedpipervideochat.com/'; // or pull from config
$client = null;
$client = new FusionAuthClient($fusionauthTenantLockedApiKey, $fusionauthBase);
----

Next, create the FusionAuth application.

==== Creating a FusionAuth Application

At this point, you are creating the configuration for the FusionAuth application. An application is anything a user can log in to. In this case, the users logging into this application will be using the video chat. So users like Patrice or Jason Winter might be loggging into the Hooli instance of the PPVC application. The hostname (`hooli` or `raviga`) is required for application configuration.

[source,php]
----
$saasRootDomain = '.piedpipervideochat.com'; // or pull from config
$ppvc_app_base = "https://".$hostname.$saasRootDomain; 

$application_object = array();
$application_object["name"] = "Default application for ".$hostname;

$application_oauthconfiguration = array();
$application_oauthconfiguration["authorizedRedirectURLs"] = [$ppvc_app_base."/login/callback"];
$application_oauthconfiguration["enabledGrants"] = ["authorization_code"];
$application_oauthconfiguration["logoutURL"] = $ppvc_app_base;
$application_object["oauthConfiguration"] = $application_oauthconfiguration;

$application_registrationconfiguration = array();
$application_registrationconfiguration["enabled"] = true;
$application_object["registrationConfiguration"] = $application_registrationconfiguration;

$application_request = array();
$application_request["application"] = $application_object;

$result = $client->createApplication('', $application_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$application = $result->successResponse;

return [$application->application->id, $application->application->oauthConfiguration->clientSecret];
----

You can see that there is an application base url, something like `https://raviga.piedpipervideochat.com`, which is constructed. This will serve as the foundation for any URLs or other data plane application specific configuration.

Users will be logging into this FusionAuth application using the OAuth Authorization Code grant, so the `oauthConfiguration` field needs to be created. In that section, the code:

* Enables the authorization code grant by configuring the `enabledGrants` field.
* Sets the value of `logoutURL`. This is where FusionAuth will send the user after they have logged out.
* Adds values to `authorizedRedirectURLs` array. 

Once this application is live, the Raviga or Hoolise users need to be created in this tenant. You have some options:

* Allow users to sign in with a social provider.
* Create users via the FusionAuth API and an automated process.
* Allow users to sign in with a enterprise provider such as an OAuth or SAML compatible identity provider.
* Let users sign up for an account.

Self service registration is enabled for this example application. Any of the above options will work when configured, though. For instance, if you wanted to allow users to sign in with Google, you'd have to create an identity provider in the <<Initial FusionAuth Configuration>>, and then assign the identity provider when creating the FusionAuth configuration for a new data plane application.

After the FusionAuth configuration is set up, store the application's Id, which is to the OAuth Client Id, and the application's Client Secret. These values need to be stored in your application's database, just as you stored the API key and tenant Id.

==== Other FusionAuth Configuration

What you just walked through is all the required configuration to allow someone to sign up or log in to the PPVC application. However, there might be other FusionAuth configuration depending on your application. You might want to:

* Add a user or set of users and register the for the new application.
* Set up roles.
* Set up groups.
* Assign users to groups and roles.
* Create specific FusionAuth API keys with limited permissions, such as a read-only user query key.

Now that FusionAuth tenants and applications will be automatically created every time a user registers in the control plane application, the next step is to look at routing user requests to the correct tenant.

=== Routing Requests to the Correct Tenant

As mentioned in <<Data Plane Application Tenant Determination>>, you must map from a request to a specific data plane application. 
Typically the hostname is used to determine the tenant. `raviga.piedpipervideochat.com` points to the Raviga data plane application and `hooli.piedpipervideochat.com` points to the Hooli one.

==== Configure DNS and Your Web Server to Handle Wildcard Domains

You need to configure your DNS and web application web server to send all requests to a host ending in `.piedpipervideochat.com` to your web application. How to do so varies depending on your DNS provider and web application server. Consult your DNS provider documentation on how to point a wildcard DNS entry to a given host. 

If you are developing locally, you can add multiple hostnames to your `/etc/hosts` file. 

[source]
----
127.0.0.1       localhost app.piedpipervideochat.com raviga.piedpipervideochat.com hooli.piedpipervideochat.com
----

Below is an example Apache configuration file to send traffic for multiple piedpipervideochat.com addresses to a proxied local web  application running on port 8000.

[source]
----
<VirtualHost *:443>
  ServerName app.piedpipervideochat.com
  ServerAlias *.piedpipervideochat.com

  ProxyPreserveHost on
  ProxyPass / http://localhost:8000/ retry=1
  ProxyPassReverse / http://localhost:8000/ retry=1
</VirtualHost>
----

Make sure you are passing the `Host` header through to the application code, since that is what is going look up the tenant object based on the hostname.

==== Look Up the OAuth Configuration Based On the Hostname

Once the request is recieved by your application, you can look up the Client Id and Secret in the tenant table in your database based on the incoming request's hostname. When a request comes in (to `https://raviga.piedpipervideochat.com/login`, for example), you can map from the hostname (`raviga`) to the appropriate Client Id. Here is some sample code:

[source,php]
----
$client_id = ''; 
$client_secret = '';
    
if ($this->isControlPlaneHost($host)) { 
  $client_id = $this->controlPlaneClientId;
  $client_secret = $this->controlPlaneClientSecret;
} else { 
  $hostname = $this->hostname($host); // converts from raviga.ppvc.com to raviga
  $repository = $this->entityManager->getRepository(Tenant::class);
  $tenant = $repository->findOneBy(array('hostname'=>$hostname));
  if ($tenant) { 
    $client_id = $tenant->getApplicationId();
    $client_secret = $tenant->getClientSecret();
  } else { 
    // throw an error, this is not a valid hostname. Doing so will allow an attacker to enumerate your supported hostnames, however.
  }
} 
return [$client_id, $client_secret];
----

The code checks to see if the host matches the control plane application. Remember, in this particular multi-tenant application, the web application responds to all requests for any users, both those creating video chat tenants and the users of those video chat tenants. This choice is discussed more in <<Should You Separate the Control Plane and Data Plane Applications?>>. 

The OAuth configuration for the control plane application is static and was created in the <<Initial FusionAuth Configuration>> section. In contrast, for the data plane applications, the configuration is dynamic, is stored in the database, and was created in <<Creating a FusionAuth Application>>. The tenant object is retrieved by the hostname and the Client Id and Client Secret are returned.

Each FusionAuth application lives in one and only one tenant, so providing the Client Id, which identifies the application, automatically ensures FusionAuth determines the correct FusionAuth tenant. The Client Id is then used to create the login, logout and registration links which are displayed in the PPVC application. These links can be used in navigation or any other location where the user might want to log in or log out.

Let's look at building those links next.

==== Create the Links

[NOTE]
====
The sample application leverages an open source library for managing and creating OAuth URLs. This library handles setting the `state` parameter and other niceties. If your web application framework or language has this type of library, using it is highly recommended. 
====

The login link uses FusionAuth's well documented OAuth endpoints as well as the client_id:

[source,php]
----
$redirectURI = '...'; // discussed below.
$fusionauthBase = 'http://login.piedpipervideochat.com/'; // or pull from config
return $fusionauthBase . '/oauth2/authorize?client_id='.$client_id.'&redirect_uri='.$redirectURI.'&response_type=code'
---

The registration URL is the same format, but uses the path `/oauth2/register` instead of `/oauth2/authorize`.

[source,php]
----
$redirectURI = '...'; // discussed below.
$fusionauthBase = 'http://login.piedpipervideochat.com/'; // or pull from config
return $fusionauthBase . '/oauth2/register?client_id='.$client_id.'&redirect_uri='.$redirectURI.'&response_type=code'
---

Because `logoutURL` was configured in the FusionAuth application configuration, FusionAuth will redirect the user to that location when the user logs out:

[source,php]
----
$fusionauthBase = 'http://login.piedpipervideochat.com/'; // or pull from config
$fusionauthBase.'/oauth2/logout?client_id='.$clientId;
----

This logout URL works with browsers. If you are using APIs for a mobile application, you should revoke the refresh token instead of using the `/oauth2/logout` endpoint.

=== Handling OAuth Callbacks 

The final auth specific functionality for supporting multiple tenants is handling the OAuth callback. You may recall that in the <<Creating a FusionAuth Application>> section, you configured a FusionAuth application with a given `authorizedRedirectURLs` value. It was something like: `https://raviga.piedpipervideochat.com/login/callback`.

You must create a part of your web application to responds to requests for that path. It will need to do the following:

* Determine the tenant from the hostname to retrieve the correct Client Id and Client secret.
* Exchange the authorization code for a token.
* Log the user in to your web application.

Let's look at each of these steps.

==== Determine the Tenant's OAuth Configuration

Mapping from the hostname like `raviga` to a certain Client Id and Secret should sound familiar.

It is exactly the same logic as what was done in the <<Look Up the OAuth Configuration Based On the Hostname>> section.

==== Exchange the Authorization Code

To perform this exchange, use an OAuth library for your language or framework. 

You can also use the FusionAuth client library:

[source,php]
----
$fusionauthBase = 'http://login.pipedpipervideochat.com/'; // or pull from config
$noApiKeyNeeded = '';
$client = new FusionAuthClient($noApiKeyNeeded, $fusionauthBase);

$result = $client->exchangeOAuthCodeForAccessToken($code, $client_id, $client_secret, $redirect_uri)
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$oauthResult = $result->successResponse;

$token = $oauthResult->access_token;
----

=== Log the User In

At this point you have an access token and a user who has successfully authenticated. You can examine the token see if the user is authorized for this FusionAuth application. You can also examine the roles assigned to this user.

At this point, your next step depends on the application framework or programming language you are using. Create a login session in your application. This is specific to your implementation, so is left as an exercise for the reader.

You may also create or update a local user record in your database. This is common. If there are other parts of your application which will be associated with a user. For example, if PPVC stores video chat metadata, tying this data to each user will take place in the application database. 

Another example is letting users send video messages; in this case a `messages` table referencing each user id would be required. You can use the FusionAuth UUID provided, or you could use an internal id. Store the FusionAuth user Id in the web application database to make correlating the two sets of data easier.

After you have set up a session in your application based on successful authentication, redirect to the chat page for the data plane application or a user profile page for the control plane application. Distinguish between these by checking the hostname again.

== Gotchas

After you've set this up, there's still more to do to build a professional grade multi-tenant SaaS application, but you have a solid foundation and your user's users will be able to login using FusionAuth.

TODO STOPPED HERE 
Other items to consider:

* Should you split out the code for control plane application (which lets users create tenant applications) and the data plane applications (the application which actually lets users use the SaaS functionality, such as a pied piper vide chat)? Both of these applications will be using the `tenant` object (the control plane to write it, the data plane to read it), so you'll need to either share a database or have some other way of syncing up that data. If you use the same web application, you'll want to gate which controllers are available based on whether the control plane or a data plane application is executing. 

* Email addresses for your local user object. Often times a web framework will want a unique email address for the local user record. But FusionAuth tenants have a separate userspace. I can sign up for raviga.ppvc.com and hooli.ppvc.com with the same richard@fusionauth.io address. To address this, you can either use a compound key for the email address, or you can prepend the FusionAuth user id which is guaranteed to be unique, or you could set up some other unique string. This means that when you want to present the user's email address, either to them or for reporting or marketing purposes, you'll need to retrieve it from FusionAuth.

* You should handle tenant deletion as well as creation. When a user deletes their account, you'll want to make a call to FusionAuth to remove the FusionAuth configuration as well. You are able to do that with a call to the link:/docs/v1/tech/apis/tenants/#delete-a-tenant[Delete Tenant API].

== API Calls

If you are not using a tenant scoped API key, you should provide a tenant Id in all of your API calls. There are cases where the tenant can be inferred from another identifier (such as when you provide an application Id) but there are other times where it cannot (such as when you are creating a user). It's better to be consistent.

Throughout the API documentation, you'll see sections like this which will specify when the header should be used.

include::docs/v1/tech/apis/_x-fusionauth-tenant-id-header-create-operation.adoc[]


== Limits

include::docs/v1/tech/guides/_multi-tenant-limitations.adoc[]

== QUESTIONS TBD

is it multi tenant or multitenant or multi-tenant?
A: it is multi-tenant see https://fusionauth.io/features/architecture/

ppvc.com? piedpipervideochat.com (register the latter)

https://github.com/fusionauth/fusionauth-issues/issues/91

diagram of applications?

TBD
deletion of tenants and api keys
async configuration setup
the local user table
unique email addresses
mapping to users in your application
navigation
single web app or multiple apps

webapp vs fusionauth app? define at beginning

for fusionauth cloud
no, you just send the client id, and we know which tenant to holds that client id

I don't love objects, but don't want to overload the term entities.

set up page for piedpipervideochat.com

client secret/client id capitalization

do I need some images for the sample application?
