---
layout: doc
title: Multi-tenant setup
description: How to run multiple tenants within a single FusionAuth instance
---

:page-liquid:

== Overview

This guide will help you set up a multi-tenant application in FusionAuth. Tenants allow for logical separation of users, applications and other objects in FusionAuth.

TOC TODO

== Why Use Multi-Tenancy

There are many reasons why you might be interested in a multi-tenant FusionAuth instance:

* The logical separation. While you have only one FusionAuth instance to manage, users, applications, API keys, and many other configurable objects are logically distinct.
* You might be interested in building an application which you'll offer as a service, often called SaaS (Software as a Service). In this case, each different customer can be modeled as a tenant. 
* Managing different deployment environments. For instance, on one FusionAuth instance, you could run integration, user acceptance and developer environments. It's not recommended to run the production on the same instance as other environments, however.
* Managing multiple developer environments. You also might want to provide a tenant for each developer on a dedicated development server. This would allow developers free reign to add, remove and modify objects in their FusionAuth tenant, while keeping them relatively insulated from each other.
* You need different tenant level settings for clients. Examples of such settings include password rules, the issuer of JWTs, or webhook transaction levels.

FusionAuth's performant, lightweight multi-tenancy can help with any of these scenarios.


XXX TODO?
== The PiedPiper Video Chat Application

To make things a bit more concrete, let's use an example. Suppose you wanted to build a Pied Piper Video Chat (or PPVC for short) SaaS application. Similar to Slack, but with a patented middle out compression algorithm. This application will have support multiple different, entirely distinct groups of users. Each user who signs up picks their own hostname, which sets up an application that can be logged into by others. 

The PPVC will charge each instance a rate of $7/user/month. The creator of the PPVC application will be able to pic a hostname and a display background color. If someone from Hooli joins, they'll have `hooli.piedpipervideochat.com`, for example.


== Multi-Tenant Concepts

However, before this guide covers how to set up a multi-tenant application with FusionAuth, let's cover what can be configured at the The FusionAuth tenant level. There are five general categories of modifiable objects in FusionAuth:

* Tenant scoped objects
* Tenant attached objects
* Application scoped objects
* Application attached objects
* Global objects

A "scoped" object is contained within the enclosing configurable object. If the latter is deleted, the former will be as well. For instance, both users and groups are scoped to a tenant, and when that tenant is deleted, the enclosed users and groups are too. Scoped objects cannot be shared between multiple configuration objects to which they are scoped. If the PPVC application has groups for different user privileges, each tenant needs to have its own group. For example, an "Admin Group" or "Moderator Group" would have to be created in each tenant.

An "attached" object, on the other hand, is linked to a different object, but if the latter is deleted, the former still exists. For instance, a signing key, created by using [breadcrumb]#Settings->Key Master#, can be associated with a tenant. When that tenant is deleted, the association is removed, but the signing key remains in the system. 

Attached objects can be shared. For example, the PPVC can use the same signing key between the `hooli.piedpipervideochat.com` and the `raviga.piedpipervideochat.com` tenant configurations. In some cases attached objects support overriding configuration for different behavior.

TBD extract to share with core concepts?

Let's examine each of the above categories.

=== Tenant Scoped 

Here is a partial list of tenant scoped objects:

* Users
* Groups
* API Keys (optionally)
* Applications
* Entities

=== Tenant Attached 

Here is a partial list of tenant attached objects:

* Email templates (some of them)
* Forms (some of them)
* Themes
* Connectors
* Consents
* User actions
* Webhooks

=== Application Scoped

Here is a partial list of application scoped objects:

* Registrations
* Roles

Since an application is tenant scoped, the above entities are also tenant scoped and cannot be used between different FusionAuth tenants. For example, if an application has an "admin" role, when the tenant containing the application is deleted, the "admin" role is as well.

=== Application Attached

Here is a partial list of application attached objects:

* Identity providers
* Email templates (some of them)
* Forms (some of them)
* Lambdas

=== Global Objects

There a few objects which are globally available. These are typically available under the `system` path in the API namespace.

* API Keys (optionally)
* Login reports
* Logs
* CORS settings

If you need separation of global configuration, or if you need true physical separation due to different regulatory regimes, run multiple FusionAuth instances. If you need to sync configuration between them, script your changes using the API, terraform provider, or client libraries.

== Components of a Multi-Tenant Setup

While FusionAuth multi-tenancy can help with many different scenarios, as mentioned above, this section will focus on building out the Pied Piper Video Chat SaaS application.

Unapologetically borrowing from https://en.wikipedia.org/wiki/Control_plane[network routing], you need to build a control plane application to manage user and tenant creation. This is also where you can integrate billing and general account management if you are charging for your application. Each application actually providing the video chat functionality will be called a data plane application. Here are common components for a multi-tenant application of this type:

* The control plane application
* The data plane application
* FusionAuth tenants and applications
* Data plane application tenant determination 
* Initial and deferred tenant setup components
* The tenant object

Let's look at each of these briefly. 

=== The Control Plane Application

When you have a multi tenant SaaS application, you need some way to manage those tenants. PPVC must have a web or mobile application where users can sign up for Pied Piper Video Chat for their company. The users may be able to do other tasks, like set up the PPVC hostname, customize the look and feel, and set up billing. PPVC needs to charge that $7/user/month fee. But this control plane application doesn't support video chat itself. The control plane application is a tenant management portal.

For PPVC, this will likely be a web application, but the actual implementation details matter much for the purposes of illustrating multi-tenancy.

=== The Data Plane Applications

Data plane applications offer functionality to PPVC's users users. So Hooli employees will log into `hooli.piedpipervideochat.com` to chat amongst themselves, and Raviga employees will do the same in the `raviga.piedpipervideochat.com` application. Within each data plane application, users can have roles and other accounts options such as payment or language preferences. 

The features of this application aren't the same as that of the control plane application. Tenant management is not part of this application. There may be no overlap in the users of this application and the control plane application either. 

For PPVC, the data plane application will likely be a web application, but it could also be a mobile application as well. The actual implementation details don't really matter for the purposes of this guide.

==== Should You Separate the Control Plane and Data Plane Applications?

The control plane and data plane applications are conceptually different, but do not need to be physically distinct. You could, in other words, implement them within the same web application. 

Doing so may make sense initially. There will be database overlap between them and it may be easier to operate a single application than to create two distinct web or mobile applications.

As you grow, you may want to split these apart. They will probably have different SLAs, and they'll have different features and release cycles. For an initial implementation, it will be simpler to build them as a single deployment artifact, and that's what this guide will do.

=== FusionAuth Tenants and Applications

For each of the web, mobile or other applications that are built, corresponding FusionAuth configuration objects need to be created. The control plane application will have a corresponding FusionAuth tenant where the users of the control plane application will be stored. It will also have a FusionAuth application object which contains application specific settings, such as whether a user can self register. Each data plane application will also have a FusionAuth tenant and a FusionAuth application. 

For the PPVC control plane web application, a FusionAuth tenant object and FusionAuth application object must be created. Each time a user signs up and creates a new PPVC host, there'd also be a new data plane tenant. (This is similar to how Slack works--I can create a `dan1234` Slack tenant and someone else can create a `jen1234` Slack tenant.) If an employee at Raviga signs up for PPVC, a new FusionAuth tenant object will be created for Raviga, and within that tenant a new FusionAuth application object. This Raviga tenant would be where all users of the Raviga PPVC application are stored. 

The mapping between the data plane application configuration and the corresponding FusionAuth tenant and application objects must be stored somewhere. In this example, each data plane application has a hostname and background color, as well as FusionAuth configuration information. This additional metadata should be stored in the application database. This will be looked at more deeply in <<The Tenant Object>> section.

=== Data Plane Application Tenant Determination 

The data plane web application needs to differentiate between the different tenants. If the code is hosted at piedpipervideochat.com, there are a few ways to send users to the appropriate tenant.

* The hostname: `raviga.piedpipervideochat.com` points to the Raviga instance of the application. `hooli.piedpipervideochat.com` point to the Hooli instance. As mentioned above, this is similiar to how Slack operates.
* User choice: A user logs in and is presented with a list of data plane applications to which they can login (or transparently SSO into). In this case, you can present this option in the control plane application. This requires syncing user data between the different tenants.
* User or request attributes: If there is an attibute of the client or incoming request which can indicate the correct tenant, that can be used to route the user to the correct location. For instance, if the system can read network information or user agent attributes to determine the appropriate data plane application, it should do so. 

In many cases, a distinct hostname is the easiest way to differentiate. This is memorable to the user, works well with internet standards like cookies, and scales well. That's the approach this guide will take.

=== Tenant Setup

STOPPED HERE

When a user signs up in the control plane application and creates a new tenant, there are a number of things that need to happen.

The following configuration needs to occur:

* Hostname setup, which can be handled with DNS wildcarding
* Creation of a FusionAuth tenant and a FusionAuth application. This will allow the new data plane application to let users log in.
* Any needed configuration of the data plane application. For example, the PPVC application might allow users at a premium level to have 10 chat rooms, whereas users at the basic level could only have 2. 

Since the new tenant application isn't usable without these configuration settings, they should take place synchronously. 

There is also some optional configuration:

* Creating a user within the FusionAuth tenant for initial sign in.
* Creating any FusionAuth roles that might be applicable, such as an `admin` role.
* Customizing the theme of the FusionAuth hosted login pages with items like custom colors and logos.

Since the new tenant application is usable without these changes, they can take place asynchronously. 

=== The Tenant Object

Within your control plane application's datastore, you'll want to store metadata about the tenants. This is useful both for the users to modify their information, for the data plane application to deliver proper functionality, and for reporting as your business grows. 

This tenant object could have customization information.

Here are some attributes you might need in your tenant object if you were implementing multitenancy with FusionAuth:

* Owning user id: which user created this tenant. It could be a one to one, or one to many mapping depending on your needs.
* Hostname: the user selected hostname to which users of the PPVC chat application for an organization will go. Something like raviga.ppvc.com
* FusionAuth tenant id: the tenant created in FusionAuth during the setup.
* FusionAuth client id and client secret: these are used during the login process for the data plane application.
* Custom attributes such as a logo or background color for the hosted login pages. 
* An API key and API key id. This is useful if the control plane application needs to modify FusionAuth configuration. This API key could even be exposed to the administrators of the data plane application to, for example, write a script to pull a list of their users.

== Registration and Login Flows

Let's get more concrete. Here are is the registration flow for the control plane application. 

++++
{% plantuml source: _diagrams/docs/guides/control-plane-registration.plantuml, alt: "Registration process for the control plane application." %}
++++

Here's the login flow for a data plane application. Note that apart from the lookup of the tenant configuration by hostname, this is a pretty typical Authorization Code grant.

++++
{% plantuml source: _diagrams/docs/guides/data-plane-login.plantuml, alt: "Login process for the data plane application." %}
++++

== Building Required Components

When building a multi tenant application, you need the following components:

* Initial FusionAuth configuration of the control plane application.
* A tenant object in your database, as well as CRUD methods to manage it.
* A way to create and delete required FusionAuth configuration for the data plane applications.
* Some way for user login, registration and logout requests to be routed to the correct FusionAuth tenant.
* The callback handling for the authorization code.

Let's look at each of these. You can download, review and run a https://github.com/FusionAuth/fusionauth-example-symfony-multitenant[fully functional multi-tenant chat application].

=== Initial FusionAuth Configuration

The control plane FusionAuth application needs to be configured in FusionAuth. You can create this in its own tenant to increase isolation.
You also need to create a Key Manager API key. Navigate to [breadcrumb]#Settings -> API Keys# and create a global API key. Make sure you enable [field]#Key manager# as this will be used to mint new tenant scoped API keys.

You should enable the following:

* A redirect URL
* The authorization code grant
* Self service registration, if desired
* Roles, if desired

pic TBD

You also need to create a Key Manager API key. Navigate to [breadcrumb]#Settings -> API Keys# and create a global API key. Make sure you enable [field]#Key manager# as this will be used to mint new tenant scoped API keys.

pic TBD

And you'll want to create a separate tenant to serve as a blueprint for all newly created tenants. This is the tenant with the default settings for the data plane FusionAuth tenants. You can set things like email configuration, password complexity and other settings. Of course, you can customize these for each tenant, but having a blueprint to copy makes the initial new FusionAuth tenant setup easier.

pic TBD

Instead of running through these manually, you can also download this kickstart file and run it using link:/docs/v1/tech/installation-guide/kickstart[Kickstart]. TBD put here: https://github.com/fusionauth/fusionauth-example-kickstart

=== The Tenant Object

The tenant object lives in your application. This will serve as the storage location for all tenant related information. This includes anything your application needs, such as background color, logo, plan level, or business domain specific data. It also includes FusionAuth specific information such as API keys and OAuth configuration information.

Here's a sample tenant table definition:

[source,sql,title=Tenant script]
----
CREATE TABLE `tenant` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `hostname` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `background_color_code` varchar(6) COLLATE utf8mb4_unicode_ci NOT NULL,
  `fusion_auth_tenant_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `api_key` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `api_key_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `client_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `client_secret` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UNIQ_4E59C462A76ED395` (`user_id`),
  CONSTRAINT `FK_4E59C462A76ED395` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
----

This implementation maps each tenant to a single user, becuase `user_id` is a foreign key into the local `user` table. You could choose to allow users to create multiple tenants as well. You'll need to create a CRUD interface to create this row and populate the application specific fields, such as background color and host. 

[NOTE]
====
You could use link:advanced-registration-forms/[Advanced Registration Forms], a premium feature, to capture all the needed tenant eetup information, such as hostname, and then use a webhook to create the FusionAuth configuration and the tenant object in your application database too.
====

The hostname is worth emphasizing, since it will come up repeatedly. Remember, this guide is building a video chat application. The hostname is how the application will differentiate between different tenants. raviga.ppvc.com would point to the Raviga instance of the application. And hooli.ppvc.com would point to the Hooli instsance, similiar to how Slack operates.

You can either let the user pick the hostname (`raviga`) or assign it (`tenant123`). In either case, it will be prepended to the domain name (`ppvc.com`) for the end user. You could of course also let the user choose an entirely different host (`chat.hooli.com`) and the same principles apply.

The FusionAuth specific fields in this table are:

* `fusion_auth_tenant_id`: the UUID representing the tenant.
* `api_key`: a tenant locked API key.
* `api_key_id`: the Id of the tenant locked API key. This is useful if you want to manage this API key.
* `client_id`: the client Id of the data plane FusionAuth application. Used to direct users who are interacting with FusionAuth to the correct client.
* `client_secret`: the corresponding client secret.

You'll see how to set the FusionAuth specific fields next.

== Updating the Tenant Object With FusionAuth Configuration

Next, you need a way to create and delete required FusionAuth configuration for the data plane applications.

[NOTE]
====
You can use link:/docs/v1/tech/client-libraries/[any of the client libraries] to create FusionAuth configuration. This document happens to use PHP, but you should use whatever language suits your project.

Client libraries are used by creating JSON objects as documented by the link:/docs/v1/tech/apis/[APIs] and then calling methods named after the operations in those same document.
====

This is going to depend on your application framework and requirements. You have a couple of options for calling the FusionAuth APIs to configure the new tenant:

* In the same controller where you create the row in the tenant table, call the APIs.
* Use a queue. Put a message on the queue when a new tenant row is added, then have a listener retrieve the message and create the configuration.
* Use a pre-persist method to call the APIs before the tenant is saved.

For the example application, I used the latter method. Before the tenant information is saved to the application database, the FusionAuth APIs are called and the needed FusionAuth configuration is created. What makes sense depends on how many new tenants you expect to be created and how much configuration you need to do. 

The minimal amount of FusionAuth configuration is:

* Creating the tenant. 
* Setting up a tenant locked API key.
* Using the new tenant locked API key, create the application.
* Store off these values in your database.

Let's take a deeper look at each of these.

=== Creating the FusionAuth Tenant 

The easiest way to do this is to pull the blueprint tenant, extract unchanged configuration and then create the new tenant.

Here's some PHP code to do this:

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$client = new FusionAuthClient($fusionauthKeyManagerKey, $fusionauthBase);

$result = $client->retrieveTenant($this->blueprintTenantId);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$blueprint_tenant = $result->successResponse;

// pick off what we know we want to minimize forward compatibility issues.

$tenant_object = array();
$tenant_object["name"] = $tenant->getHostname();
$tenant_object["themeId"] = $blueprint_tenant->tenant->themeId;
$tenant_object["issuer"] = 'https://'.$tenant->getHostname().".ppvc.com";

$tenant_email_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->emailConfiguration);
$tenant_object["emailConfiguration"] = $tenant_email_configuration;

$tenant_jwt_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->jwtConfiguration);
$tenant_object["jwtConfiguration"] = $tenant_jwt_configuration;

$tenant_externalId_configuration = $this->convertObjectToArray($blueprint_tenant->tenant->externalIdentifierConfiguration);
$tenant_object["externalIdentifierConfiguration"] = $tenant_externalId_configuration;

$tenant_request = array();
$tenant_request["tenant"] = $tenant_object;

$result = $client->createTenant('', $tenant_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
} 

$new_tenant = $result->successResponse;
return $new_tenant->tenant->id;
----

In this code, you can see that the following configuration is extracted from the blueprint tenant:

* `themeId`
* `emailConfiguration`
* `jwtConfiguration`
* `externalIdentifierConfiguration`

There are only a few things configured differently. The name of the tenant, which is set to the hostname, and the issuer, which is set to the expected host. At this point, you could also tweak any of these settings as needed. 

==== The Tenant Locked API Key

You should set up a tenant locked API key for two reasons:

* You can use it for all other configuration of this FusionAuth tenant, following the principle of least privilege.
* You can expose it to your clients to use for their own purposes, such as managing users.

You could also create two different tenant locked API keys, one which can create new API keys (a key manager) and one which could be used for internal management of the FusionAuth configuration. Then, if customers needed API keys to do certain tasks such as access user data, you could issue a limited permissions key.

Here's code to create the tenant scoped API key:

[source,php]
----
$apikey_object = array();
$apikey_object["metaData"]["attributes"]["description"] = "API key for ".$hostname;
$apikey_object["tenantId"] = $fusionauth_tenant_id;

$apikey_request = array();
$apikey_request["apiKey"] = $apikey_object;

$result = $client->createAPIKey('', $apikey_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$apikey = $result->successResponse;

return [$apikey->apiKey->id, $apikey->apiKey->key];
----

You need to store this key in your application's database. Both the key string and the Id are stored. The key string can be used to make other API calls. The API key id is used to manage the key in the future, if needed.

The next thing you should do after creating the API key is create a new FusionAuth client with the limited key.

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$client = null;
$client = new FusionAuthClient($fusionauthTenantLockedApiKey, $fusionauthBase);
----

Then, you want to create the application. Let's look at that next.

==== Creating a FusionAuth Application

[source,php]
----
$saasRootDomain = '.ppvc.com'; // or pull from config
$ppvc_app_base = "https://".$hostname.$saasRootDomain;

$application_object = array();
$application_object["name"] = "Default application for ".$hostname;

$application_oauthconfiguration = array();
$application_oauthconfiguration["authorizedRedirectURLs"] = [$ppvc_app_base."/login/callback"];
$application_oauthconfiguration["enabledGrants"] = ["authorization_code"];
$application_oauthconfiguration["logoutURL"] = $ppvc_app_base;
$application_object["oauthConfiguration"] = $application_oauthconfiguration;

$application_registrationconfiguration = array();
$application_registrationconfiguration["enabled"] = true;
$application_object["registrationConfiguration"] = $application_registrationconfiguration;

$application_request = array();
$application_request["application"] = $application_object;

$result = $client->createApplication('', $application_request);
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$application = $result->successResponse;

return [$application->application->id, $application->application->oauthConfiguration->clientSecret];
----

Here you are creating an application. You can see that there is an application base url, something like `https://raviga.ppvc.com`, which is built. Next you need to configure various parts of the OAuth config.

First, configure the OAuth portion of the application. 

* Enable the authorization code grant with the `enabledGrants` field. (Here's an link:/docs/v1/tech/oauth/#example-authorization-code-grant[example authorization code grant]).
* Set up the `logoutURL`. This is where FusionAuth will send the user after they have logged out.
* Set up the `authorizedRedirectURLs`. These are URLs to which FusionAuth will send the authorization code. The controller here should exchange that code for a token. At this point the user is logged in.

Remember, this is going to represent `raviga.ppvc.com`, and so the Raviga users will need to be created in this tenant in some fashion. You could:

* Allow users to sign in with a social provider.
* Create users via the API through an automated process.
* Allow users to sign in with a enterprise provider such as an OAuth or SAML compliant identity provider.
* Let users sign up for an account with basic or advanced registration forms.

Here, self service registration is enabled for this application. Any of these will work, though. If you choose a different one, you'd use different API calls to configure the application or other parts of FusionAuth. For instance, if you wanted to allow anyone to sign in with Google, you'd have to create an identity provider in the <<Initial FusionAuth Configuration>>, and then assigned the identity provider to the created FusionAuth application.

Finally you are going to need the application's Id, which corresponds to the OAuth client Id, and the application's client secret, which corresponds to the OAuth client secret. These values should be stored in your application's database, just like you stored the API key.

==== Other FusionAuth Configuration

The above is all that is required to let users log in to and register for the new FusionAuth tenant. Other FusionAuth actions you might want to take:

* Add a user or set of users and register the for the new application.
* Set up roles.
* Set up groups.
* Assign users to groups and roles.
* Set up specific FusionAuth API keys with limited permissions for certain purposes.

== Routing Requests to the Correct Tenant

As mentioned in <<Data Plane Application Tenant Determination>>, you need to have some way to map from a request to a FusionAuth application. Each FusionAuth application lives in one and only one tenant, so mapping to the application is an easy way to map to a tenant. There may be situations where you want to map directly to the tenant and then perhaps offer a list of applications to sign in to, but that is beyond the scope of this guide.

Typically the hostname is used to determine the tenant. So `raviga.ppvc.com` points to the Raviga tenant and `hooli.ppvc.com` points to the Hooli tenant. 

=== Configure DNS and Your Web Server to Handle Wildcard Domains

You need to configure your DNS and web application web server to send all requests to a host ending in `.ppvc.com` to your web application. How to do so varies depending on your DNS provider and web application server.

Consult your DNS provider documentation on how to point a wildcard DNS entry to a given host. 

If you are developing locally, you can add multiple hostnames to your `/etc/hosts` file. 

[source]
----
127.0.0.1       localhost app.ppvc.com raviga.ppvc.com hooli.ppvc.com
----

Here's an example Apache configuration to send traffic for multiple ppvc.com addresses to a given web server. Consult your web server documentation for appropriate configuration.

[source]
----
<VirtualHost *:443>
  ServerName app.ppvc.com
  ServerAlias *.ppvc.com

  ProxyPreserveHost on
  ProxyPass / http://localhost:8000/ retry=1
  ProxyPassReverse / http://localhost:8000/ retry=1
</VirtualHost>
----

=== Look Up the OAuth Configuration Based On the Hostname

Once the request is recieved by your web application, you previously stored the hostname and the client Id/secret in the tenant table in your database. When a request comes in for a login (to `https://raviga.ppvc.com/login`, for example), you can map from the hostname (`raviga`) to the appropriate client Id. Here is sample code:

[source,php]
----
$client_id = ''; 
$client_secret = '';
    
if ($this->isControlPlaneHost($host)) { 
  $client_id = $this->controlPlaneClientId;
  $client_secret = $this->controlPlaneClientSecret;
} else { 
  $hostname = $this->hostname($host); // converts from raviga.ppvc.com to raviga
  $repository = $this->entityManager->getRepository(Tenant::class);
  $tenant = $repository->findOneBy(array('hostname'=>$hostname));
  if ($tenant) { 
    $client_id = $tenant->getApplicationId();
    $client_secret = $tenant->getClientSecret();
  } else { 
    // throw an error, this is not a valid hostname. Doing so will allow an attacker to enumerate your supported hostnames, however.
  }
} 
return [$client_id, $client_secret];
----

There are a couple of items worth pointing out here.

First, the code checks to see if the host matches the control plane application. Remember, in this particular multi-tenant application, the web application responds to all requests for any users, both those creating video chat tenants and the users of those video chat tenants. The OAuth config for the former is static and was created in the <<Initial FusionAuth Configuration>>. The latter is dynamic, stored in the database and was created in <<Creating a FusionAuth Application>>.

For the latter situation, you look up the tenant object by the hostname and return the client Id and client secret.

This is then used to create the login, logout and registration links. These links can be placed in your application's navigation or any other location where the user might want to login and log out.

Let's look at those next.

=== Create the Links

The sample application leverages an open source library for managing and creating OAuth URLs. You'll need to provide the `client_id`. This library handles setting the `state` parameter and other niceties. If your web application framework or language has this type of library, using it is highly recommended. 

However the login link generating function can be as simple as this:

[source,php]
----
$redirectURI = '...'; // discussed below.
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
return $fusionauthBase . '/oauth2/authorize?client_id='.$client_id.'&redirect_uri='.$redirectURI.'&response_type=code'
---

The registration URL is the same format, but uses the path `/oauth2/register` instead of `/oauth2/authorize`.

[source,php]
----
$redirectURI = '...'; // discussed below.
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
return $fusionauthBase . '/oauth2/register?client_id='.$client_id.'&redirect_uri='.$redirectURI.'&response_type=code'
---

Finally, the logout URL. Because we configured the `logoutURL` of the FusionAuth application, FusionAuth will redirect the user to the proper location after logging the user out of FusionAuth. All you need to provide is the `clientId`.

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$fusionauthBase.'/oauth2/logout?client_id='.$clientId;
----

You can then use these functions whenever you present a login, registration or logout link. 

== Handling OAuth Callbacks 

The final piece is handling the OAuth callbacks. You may recall that in the <<Creating a FusionAuth Application>> section, you configured a FusionAuth application with a given `authorizedRedirectURLs` value. It was something like: `https://raviga.ppvc.com/login/callback`.

You must create a part of your web application that responds to that path. It will need to do the following things:

* Determine what the correct tenant is so you can use the correct client Id and client secret.
* Exchange the authorization code for a token.
* Log the user into your web application.

Let's look at each of these.

=== Determine the Tenant's OAuth Configuration

This is exactly the same as the <<Look Up the OAuth Configuration Based On the Hostname>> step.

=== Exchange the Authorization Code

You should leverage the OAuth libraries available. You can also use the FusionAuth client library as well:

[source,php]
----
$fusionauthBase = 'http://login.ppvc.com/'; // or pull from config
$noApiKeyNeeded = '';
$client = new FusionAuthClient($noApiKeyNeeded, $fusionauthBase);

$result = $client->exchangeOAuthCodeForAccessToken($code, $client_id, $client_secret, $redirect_uri)
if (!$result->wasSuccessful()) {
  $this->logger->error('An error occurred!');
  $this->logger->error(var_export($result,TRUE));
  throw new FusionAuthException("Can't save: ".var_export($result,TRUE));
}

$oauthResult = $result->successResponse;

$token = $oauthResult->access_token;
----

=== Log the User In

At this point you have an access token. You can examine it to see if the user is authorized for this FusionAuth application. You can also examine the roles assigned to this user in FusionAuth. 

You should create a login session in your application. This is framework specific, so is left as an exercise for the reader.

You can also create or update a local user record. This can be useful if there are other parts of the application which will be tied to a user. For example, if you are going to store video chat metadata, you will want to tie the chat to each user. If you wanted to let users send video messages, you'd want to have a `messages` table referencing each user id. You can use the FusionAuth UUID provided, or you could use an internal id. Your user should store the FusionAuth user Id in the web application database. This will make correlating the two sets of data easier.

After this you can redirect to the chat page for the data plane applications or a user profile page for the control plane applicatoin. Again, you can distinguish between these by checking the hostname.

== Gotchas

After you've set this up, there's still a fair bit more to do to build a professional grade multi-tenant SaaS application, but you have a solid foundation.

Other items to consider:

* Should you split out the code for control plane application (which lets users create tenant applications) and the data plane applications (the application which actually lets users use the SaaS functionality, such as a pied piper vide chat)? Both of these applications will be using the `tenant` object (the control plane to write it, the data plane to read it), so you'll need to either share a database or have some other way of syncing up that data. If you use the same web application, you'll want to gate which controllers are available based on whether the control plane or a data plane application is executing. 

* Email addresses for your local user object. Often times a web framework will want a unique email address for the local user record. But FusionAuth tenants have a separate userspace. I can sign up for raviga.ppvc.com and hooli.ppvc.com with the same richard@fusionauth.io address. To address this, you can either use a compound key for the email address, or you can prepend the FusionAuth user id which is guaranteed to be unique, or you could set up some other unique string. This means that when you want to present the user's email address, either to them or for reporting or marketing purposes, you'll need to retrieve it from FusionAuth.

* You should handle tenant deletion as well as creation. When a user deletes their account, you'll want to make a call to FusionAuth to remove the FusionAuth configuration as well. You are able to do that with a call to the link:/docs/v1/tech/apis/tenants/#delete-a-tenant[Delete Tenant API].

== API Calls

If you are not using a tenant scoped API key, you should provide a tenant Id in all of your API calls. There are cases where the tenant can be inferred from another identifier (such as when you provide an application Id) but there are other times where it cannot (such as when you are creating a user). It's better to be consistent.

Throughout the API documentation, you'll see sections like this which will specify when the header should be used.

include::docs/v1/tech/apis/_x-fusionauth-tenant-id-header-create-operation.adoc[]


== Limits

include::docs/v1/tech/guides/_multi-tenant-limitations.adoc[]

== QUESTIONS TBD

is it multi tenant or multitenant or multi-tenant?
A: it is multi-tenant see https://fusionauth.io/features/architecture/

ppvc.com? piedpipervideochat.com (register the latter)

https://github.com/fusionauth/fusionauth-issues/issues/91

diagram of applications?

TBD
deletion of tenants and api keys
async configuration setup
the local user table
unique email addresses
mapping to users in your application
navigation
single web app or multiple apps

webapp vs fusionauth app? define at beginning

for fusionauth cloud
no, you just send the client id, and we know which tenant to holds that client id

I don't love objects, but don't want to overload the term entities.
