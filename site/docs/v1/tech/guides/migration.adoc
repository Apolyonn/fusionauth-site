---
layout: doc
title: Migration Guide
description: How to migrate your users to FusionAuth.
---
:page-liquid:

== Overview

This guide will help you migrate your existing users to FusionAuth. It covers the types of migrations available and walks through the phases of a successful migration.

== Types of Migrations

There are three types of user data migrations. 

* Migrate everyone at once, also known as a "big bang" migration.
* Segment your users and migrate each segment in a series of small bang migrations.
* Migrate when a user authenticates, also known as "slow migration".

Each of these moves user and other associated account data into FusionAuth from one or more other systems of record. These each have strengths and weaknesses. All three are supported by FusionAuth, so you should pick the one which works best for your situation.

=== The Big Bang Migration

With a big bang migration, you are moving all your users at one moment in time. The basic steps are:

* Map user attributes from the old system to the new system.
* Build a set of migration scripts or programs. 
* Test it well; check for migration accuracy as well as duration. 
* Plan to modify your applications to point to the new system.
* When you are ready to migrate, arrange for an adequate period of downtime, then run the scripts or programs.
* Flip the system of record for all your users from the old to the new.

This approach has some strengths:

* Depending on the downtime, the migration can have minimal impact on your users.
* It has a fixed timeframe. When you are done with the migration, you're done (unless you have to rollback).
* If you have to decomission the old system by a deadline (perhaps due to an upcoming license renewal) you can plan to migrate before that date.
* You only have to run two user datastores in production for a short period of time.
* People accessing user data, such as customer service reps, only need to switch their working routines after the migration is performed.

It also has some downsides:

* It is common to miss an issue during testing because by definition this is a one time process. Production systems are often different in subtle ways from testing environments. Leave time to fix unpleasant surprises.
* If there is any issue, many users will be impacted, since all were migrated.
* The big bang requires you to write code which you'll test intensely, use once and then throw away. Such code is the cost for the benefits.
* You need to ensure the new auth system is compatible with the old system passwords hashes. The alternative is to force all users to reset their password.

=== Segment by Segment Migration

Segment by segment migration is the second alternative. It can be thought of as a series of "little bang" migrations. Split user data in a natural way, then migrate each segment. Some natural division points could be type of user, applications used or even recency of login.

Such a segment by segment migration lets you test your processes in production by migrating less critical, or more understanding, sets of users first. The engineering team will be more understanding of issues than paying customers. 

You will probably be able to reuse code between the different segments. In general, this approach decreases risk when compared to the one time big bang migration.

However, this approach is not without its issues:

* You have multiple projects and downtimes to manage, not just one.
* There may be no natural divisions in your user base.
* If most of the users are in one segment, it may not be worth the extra effort. For example, if you have one popular application and a couple nascent apps, the extra time to migrate in phases might not be worth it.
* This will take longer to complete, requiring you to run both systems for longer.

=== Migrate On Authentication

This approach is the logical extension of the segment by segment approach; each segment is a single user. However, it has different fundamental characteristics and presents a different set of tradeoffs.

With a slow migration, you set up a connection between the old system and the new system. The new system takes all auth requests, but delegates them to the old system. The old system returns the information and the new system stores it.

To implement this, you need to have some way for the new system to pass auth information (username and password or other credentials) to the old system and get user information returned. And you need to modify your applications to point to the new auth system.

Once it is set up, a slow migration happens in phases. Each user proceeds through the phases independently of other users. 

* Initially, the user logs into the new system, but authentication decisions are delegated to the old system.
* The old system returns the user information, which is stored in the new system. This includes the password, which is hashed by the new system.
* The new system marks the user as migrated.
* The new system performs authentication for this user for all subsequent logins.

A slow migration has some benefits, too:

* Since you are only doing a user migration at the time a user authenticates, by definition the blast radius of a mistake is small; it's limited to whoever is logging in. You can decrease this further by splitting traffic and only sending a portion to the new system.
* You can upgrade your password hash algorithms transparently without requiring anyone to reset their password.
* You don't have to migrate users who aren't active. This migration is a way to scrub your userbase.
* The migration can be an opportunity to contact inactive users and encourage them to login.
* There's less downtime; you aren't moving any data. Depending on your system architecture, there may be some downtime as you direct all your users to the new auth system, rather than the old one.
* You don't have to understand all the moving pieces of the old system. You do need to be able to extend it to add the API, but you never have to connect to the underlying user datastore or understand all the business logic which goes into authentication.

However, a slow migration isn't the right solution for every system. Issues to be aware of:

* You are passing a user's plaintext password from the new auth system to the old auth system. Therefore, you should take special care to secure this data in transit. For an additional layer of security, have the new auth system encrypt the password, and have the old auth system endpoint decrypt it before authenticating.
* Both the new and old systems have to be extensible or support a standard like LDAP.
* You have to run both the new and old systems for the length of your migration. Depending on the state of the old system, this may be more or less painful.
* Customer service and other internal users may have to access two systems to find a user during the migration period.
* Rollback from a phased migration is more complex if there are any issues, because there are two systems of record, one for users who have been migrated and one for users who have not yet been moved.

== Migration Implementation

To implement any of the above migration strategies and bring your users into FusionAuth, there are N phases.

=== Core Concepts

Before you plan to move data to FusionAuth, read the link:/docs/v1/tech/core-concepts/[Core Concepts documentation]. Important concepts are users, applications, roles, groups, registrations and tenants:

* A tenant is a top level object that contains users, applications and groups, as well as other settings.
* Applications have roles. Users authenticate and are authorized to access applications.
* Groups contain users and may have associated roles. 
* Users have registrations with Applications. 

=== Planning and Assessment

The first step to any successful data migration is planning. You need to know where all your data sources are, who uses the data from the sources, how to connect to them, and what the data looks like.

Consider edge cases. What fields are required and optional in the old system (or systems)? What about the new system? Is there a clean mapping between the data fields? The answer is almost certainly no. 

Think about how you are going to handle unexpected data. You can save the entire record off for manual migration, toss it, or ignore fields that aren't clean. Which choice you make depends on the value of the record.

With FusionAuth, you have the option of storing arbitrary key value data in the user or the registration object. You can serialize the old system's user data and store it in `user.data`. The old model can be helpful in the future. If there was mistranslated data or fields, you'll have the original copy.

Consider relationships between users and other authentication related entities. Groups, application associations, roles, historical data, and anything else which the old system and is tied to accounts. Make sure you know where this data is coming from, if it should be migrated, and where it will end up. It might end up in FusionAuth, or maybe in an auxiliary datastore. 

There are two fields worth a more detailed look. The first is user ids. These are often referenced by other systems and are used for auditing, analytics or other historical purposes. If you can preserve user ids, do so. You can do this in two ways with FusionAuth.

* If your user ids are UUIDs, you can specify the user id when you are migrating each user to FusionAuth.
* If your user ids are some other format, you can store them in your `user.data` field under a key similar to `original_user_id`. You will be able to search on this value if needed.

The other notable attribute is the password, and any related fields such as a salt or hashing scheme. The means of dealing with this data depends on what kind of migration you are performing.

Finally, what should you do if you have data which doesn't map cleanly to any of the fields available in FusionAuth? FusionAuth provides a `data` field on a number of entities. These include the `user` object.

One special complexity which will require more planning is if you have user data in multiple datastores and are planning to merge the data. Ensure you map both of the old data models into the FusionAuth user data model before you write any migration code.

TBD do we need more about mapping?

==== An Example 

Let's examine a trivial data mapping example. Suppose an old auth system has a user data model with these attribute names and data types:

* `fname` - string
* `lname` - string
* `birthdate` - string
* `phone_num` - string
* `role` - string

FusionAuth has a user object with these attributes and data types:

* `firstName` - string
* `lastName` - string
* `birthDate` - An ISO-8601 formatted date string
* `mobilePhone` - string

When you are moving between them, you’ll face four challenges.

The first mapping is converting from `fname` to `first_name` and `lname` to `last_name`. This is pretty easy. Where this gets difficult is that you need to make sure you do this for each and every one of the old data sources. Spreadsheets are your friend.

The second mapping task is parsing the `birthdate` field into an ISO-8601 formatted string, to be placed in the `birthDate` FusionAuth field. Depending on how clean the original data is, this could be trivial or it could be painful. If the latter, use a date parsing library; it'll handle many more edge cases than your code.

The third issue is how to handle the `phone_num` field. In this case, if you know that every number in your original datastore is a mobile number, you could use the `mobilePhone` field. You could also store the field in the `user.data` field, which allows for arbitrary key value pairs to be stored. In this case, you would store the phone number in `user.data.phoneNumber` or a similarly named field.

Finally, we need to handle roles. Roles in FusionAuth are stored on the `registration` object, because they are associated with applications and users.

In general, any data associated with a user which won't change between different applications, such as their name, should be stored on the `User` object. Here's a sample FusionAuth `User` object:

[source,json]
.Example User JSON Request Body
----
include::docs/src/json/users/request.json[]
----

Please consult the link:docs/tech/v1/apis/users/[User API] for full documentation. 

In general, any data that is associated with a user's use of an application, such as their role or username, should be stored on the registration object. Here's a sample FusionAuth registration object:

[source,json]
.Example User Registration JSON Request Body
----
include::docs/src/json/user-registrations/create-request.json[]
----

Please consult the link:docs/tech/v1/apis/users/[Registration API] for full documentation.

As this example shows, getting ready for a migration consists of many tiny choices and design decisions. Make sure you understand the data model for your users before you start the migration.

=== Modifying Your Application

If possible, modifying your application so that users can authenticate using an OAuth/OIDC library is helpful.

TBD? not sure this section is needed.

=== Setting Up FusionAuth

Before you can migrate any user information into FusionAuth, you need to ensure it is set up correctly. 

Ensure that FusionAuth will work with your application. This may involve a short proof of concept to determine which /docs/v1/tech/core-concepts/integration-points/#login-options[login method] you should use and how to theme the hosted login pages to ensure your look and feel is maintained.

Determine where your instances should be hosted. You can use either a self hosted version, running in any data center or cloud provider, or a managed offering from FusionAuth, link:/pricing#cloud[FusionAuth Cloud].

Decide your change management strategy. How will you capture your FusionAuth settings so that you can make changes in the future in a measured, understandable way. You can either use the https://registry.terraform.io/providers/gpsinsight/fusionauth/latest[community supported Terraform provider] or script changes in your language's link:/docs/v1/tech/client-libraries/[client library]. 

Finally, decide if you are going to pursue a big bang, segment by segment or slow migration strategy.

==== Configure FusionAuth

Create one or many tenants. If you have to have separate user bases or you want different tenant level settings for your applications, you can achieve this with tenants.

Create one or many applications. An application is something which a user can log in to, whether it is an API, a commerical product, or a customer single page application.

Map user attributes, as mentioned above, into FusionAuth user or registration object attributes. If it doesn't fit into the FusionAuth schema, add it to a `data` field.

=== Big Bang Implementation

A big bang migration from an auth system into FusionAuth will involve migrating all your user data at one time.

==== Tweak Settings For Performance

When doing a big bang, tweak the FusionAuth settings to ensure an import happens as fast as possible. 

link:/docs/v1/tech/tutorials/switch-search-engines/[Switch to the database search engine] if possible. FusionAuth won't have to sync data to ElasticSearch, which will improve loading times. If you need ElasticSearch for advanced searching capabilities, revert to that search engine after the migration is complete.

If possible, disable the `user.bulk.create` webhook. Otherwise FusionAuth will try to send you an event with all the created users' data.

You will want to ensure you are setting the timeout very long on your API requests in whatever tool you’re using to make the HTTP request. Currently the import API is a synchronous operation, though there are plans to make it asynchronous (see https://github.com/FusionAuth/fusionauth-issues/issues/944[this GitHub issue for more]).

If possible, ensure your passwords are hashed; otherwise FusionAuth will hash them for you. This is a slow operation. 

Stage your data if possible by exporting current users into FusionAuth compatible JSON files. This will make debugging easier and be more performant. 

*The easiest and fastest way to load data into FusionAuth is to loop over a directory of JSON files that contain 100k users each. These JSON files should be clean, have no collisions and be minified.* In FusionAuth testing, this approach resulted in loading 100k users in 108 seconds, though of course performance is dependent on hardware, network and database constraints as well.


==== Building the Migration Scripts

Let's talk about building out the migration process. You'll want to stand up a FusionAuth instance to test out the migration process. To start your FusionAuth instance in a known state every time, you may want to configure link:/docs/v1/tech/installation-guide/kickstart[Kickstart]. This file will also serve as a foundation for developers and CI servers in the future.

You'll want scripts to drive the import, as it'll be an iterative process. You can write those in shell, any of the supported link:docs/v1/tech/client-libraries/[client library language], or against the link:docs/tech/v1/apis/users/[REST API] in any language supported HTTP calls.

If your current system hashes passwords in link:/docs/v1/tech/reference/password-encryptors/[one of the supported schemes] then simply ensure that you specify it. On the other hand, if you have a different password hashing scheme, you need to write a link:/docs/v1/tech/plugins/password-encryptors/[custom password hashing plugin]. 

If you only provide a `password` field, then FusionAuth will will assume the password is in plaintext and hash it for you. This negatively affects performance and throughput. If you provide the salt, password, encryptionScheme and factor then we will assume the value in the `password` field is a hashed password, and it will not be hashed. 

You'll iterate over all the users in your current system or systems and import them via the bulk import API. Make sure you add registrations for each application to which a user should have access.

Here's an example of an import user JSON request body. This example only imports one user, but you can add multiple user objects to the `users` array:

[source,json]
.Example User Import JSON Request Body
----
include::docs/src/json/users/import-request.json[]
----

Consult the link:/docs/v1/tech/apis/users/#import-users[documentation for this API] for more information. 

Duplicate user emails are not allowed within the same tenant. If you may have duplicate emails for a given user, de-duplicate them before importing them. Otherwise, set `validateDbConstraints` equal to `true` to be informed of such duplicate addresses. One strategy is to run imports with `validateDbConstraints` equal to `true` to find those duplicate email addresses, and then remove such duplicates. After that, you can import with `validateDbConstraints` equal to `false`.

You can import the JSON via any the `importUsers` method of any of the FusionAuth client libraries or by calling the REST API directly.

Next, determine if you need to import refresh tokens. If you are using an existing system which presents such tokens to the identity provider when an existing auth token expires, importing refresh tokens can ensure that your users enjoy an uninterrupted application experience. Consult the link:/docs/v1/tech/apis/users/#import-refresh-tokens[documentation for this API] for more information.

==== Testing

Run through this import process with as large of a dataset as you possibly can. If possible, use your entire user dataset. This will help you know how long your import will take. It will also help shake out any data edge cases, such as duplicate emails or incorrectly formatted user attributes.

Even if you aren't using multiple tenants in production, during this testing phase it is a good idea to create a `Testing` tenant and load all your users and applications into this tenant. You can drop a tenant with one API call or click in the administrative user interface, and all the users, applications, groups and settings will be removed. You cannot drop the `Default` tenant, which contains the FusionAuth application, which is why you must create a new tenant. An alternative is to drop the entire database and do a fresh FusionAuth install.

==== Performing the Migration

Once this is all tested in your testbed environment, you can prepare to go live. Make sure you inform all the internal stakeholders. Plan for downtime unless you can run your application with readonly user data. Expected downtime is dictated by the amount of time the import took on the testbed.

When the migration is finished, change your application or applications to point to FusionAuth.

TBD DNS?

Should you need to rollback, revert the changes to your application pointing it to FusionAuth. If users made changes in FusionAuth, such as changing their profile data, you'll need to consider how to port those changes back to your legacy system.

==== Segment By Segment Migration Implementation

The same processes applies to a segment by segment migration, except that you are going to split your user data into segments and migrate each segment.

=== Slow Migration Implementation

With FusionAuth, slow migration happens with link:docs/v1/tech/connectors/[Connectors]. *This feature is available in all paid editions of FusionAuth. Please visit link:/pricing/[our pricing page] to learn more about paid editions.*

==== Determine Your Finish Line

Unlike a big bang migration, with a slow migration you need to set a completion goal. Because slow migrations move users one at a time, it is unlikely you’ll migrate all of your users. Some people use your application rarely and others have abandoned their account. No matter how long the migration period, some portion of your users will not log in.

This means that you need to decide what "done" means. Consider the following when making this determination:

* How often do people log in? Is this evenly distributed? 
* Is there a significant long tail of users who visit the application less frequently than the average user?
* Are there external events such as times of the year or holidays when greater or lesser numbers of users authenticate? 
* What are the ramifications of a user being unable to log in? Are there business, compliance, legal, or security concerns? Is loss of timely access to your application an annoyance or a disaster?
* You will have some users who are not migrated. What will you do with them?
* How painful is it to operate both FusionAuth and your current authentication system?
* Is there value in a customer who has not logged in to your application in six months? A year? Three years? What is that value?

It's hard to give blanket guidance as all applications are different. But in general the more value an account has, the higher a percentage migrated you should aim for. The more painful it is to run both systems, the more accepting a low percentage makes sense, especially when combined with the possibility of doing a follow on big bang migration.

Set a goal for number or percent of migrated users, duration of the migration period, or both. Otherwise you don't know when to cut over. 

To keep track of this, you’ll want to make sure you can regularly query new and old systems to know the number of migrated accounts. Also make sure that you set a value on the `user.data` object, such as `user.data.migrated`, indicating the user was migrated.

TBD migration period

==== Build A Proxy Layer

With slow migration, FusionAuth is connecting to your previous datastore every time a user authenticates. This is typically done via either an HTTP API or LDAP connection. If your current user datastore is an LDAP database, then you don't need to build the proxy layer, since FusionAuth knows how to communicate with LDAP servers

If, on the other hand, your datastore is not LDAP, you'll need to build an HTTP API, which can be connected using a Generic Connector. This API should take a login request in JSON format:

[source,json]
.Example Migrate on Authentication Login Request JSON
----
include::docs/src/json/login/request.json[]
----

It should return a FusionAuth login response, which includes the `User` object as well as a JWT:

[source,json]
.Example Successful Login Response JSON
----
include::docs/src/json/users/login-migrated-response.json[]
----

You can see this response sets the value of `user.data.migrated` to `true`.

You can read more about the link:/docs/v1/tech/connectors/generic-connector/[Generic Connector requirements] in the documentation.

==== Configure Your Connector

Navigate to [breadcrumb]#Settings -> Connectors# and add a Connector. You can also configure Connectors by using the API; consult the link:/docs/v1/tech/apis/connectors[Connector API documentation] for more details.

image::guides/migration/add-connector.png[Adding a Connector.,width=1200]

What you need to do next depends on the type of your current data source.

===== LDAP

You'll need to configure the connection information, including the URL of the server, the method used to connect to it (LDAPS, etc), and a system account which can query across all acounts for the CN you are migrating. You'll also need to specify LDAP attributes to be returned.

With an LDAP Connector, you need to map each attribute from the LDAP database into a FusionAuth user object. You do this with an link:/docs/v1/tech/lambdas/ldap-connector-reconcile/[LDAP Connector Reconcile Lambda]. Here is a sample LDAP Connector Reconcile Lambda:

[source,javascript]
----
include::docs/src/lambda/ldap-connector-reconcile.js[]
----

Make sure you uncomment the lines where `user.data.migrated` is set to `true`.

More details about configuration are available in the link:/docs/v1/tech/connectors/ldap-connector/[LDAP Connector documentation].

===== Generic

With a Generic Connector, you'll need to configure the end URL and the security measures. The mapping of the old user data into the new system is taken care of when you build the API, so there's less to do.

Make sure you use TLS to connect to this endpoint, since you'll be sending sensitive user information.

Full configuration details are available in the link:/docs/v1/tech/connectors/generic-connector/[Generic Connector documentation].

===== Progress Mapping

As mentioned above, you want to make sure you can identify that the user has been migrated, rather than has signed up for or been created directly in FusionAuth.

An easy way to do that is to ensure that every migrated user has a `user.data.migrated` attribute set to `true`. Whichever connection you use, make sure you set this attribute.

==== Proxying Authentication

With FusionAuth, proxying authentication requests to a connector is trivial. Since you've already set up the connection information when configuring the Connector, you simply have to associate the Connector to the tenant. This is called a Connector policy. Navigate to [breadcrumb]#Tenants -> Connectors# and add a policy.

image::guides/migration/add-connector-policy.png[Adding a Connector policy.,width=1200]

Check the [field]#Migrate user# checkbox. With this setting, each user will be authenticated against the connected user datastore the first time they are seen. Their data will be migrated to FusionAuth. On subsequent authentications, they'll be migrated directly.

You can learn more about configuring the Connector in the link:/docs/v1/tech/connectors/[Connector documentation].

==== Modify Your Application 

You'll need to modify your application to authenticate against FusionAuth. How to do so is application specific, but will typically involve using a library to interface with FusionAuth's OAuth and OIDC endpoints. There are link:/docs/v1/tech/example-apps/[numerous example applications] written that might provide a path forward.

If you have self service registration, you'll need to modify your application to point to FusionAuth's registration form. If you have social, such as Google, or enterprise sign on, such as SAML, you'll need to configure and enable those providers as well.

TBD themes? assessment plan to modify app above, need to use elasticsearch

After you release this modified version of your application, your users will being to transparently be migrated into FusionAuth. 

Make sure you record the number of accounts in the old system just before cutover.

==== Monitor Progress

You can monitor your progress by comparing the number of users who have been migrated successfully with the number of users that were originally in the old user auth system. To query FusionAuth, you'd run this shell script:

[source,shell]
.Shell script to count the number of migrated users
----
API_KEY=...

curl -H "Authorization: $API_KEY" 'http://localhost:9011/api/user/search?queryString=data.migrated%3Atrue%0A'
----

This will return all the users who've been migrated as well as a count, subject to the limits of FusionAuth's Elasticsearch integration. See this https://github.com/FusionAuth/fusionauth-issues/issues/494[GitHub issue] for more on those limits. Here's an example of the output:

[source,json]
.Results of the FusionAuth migrated user query
----
{"total":629,"users": [ ... ] }
----

If you have more than 10,000 users you are migrating, query Elasticsearch directly to retrieve the count:

[source,shell]
.Shell script to count the number of migrated users directly against Elasticsearch
----
curl 'https://elasticsearch.example.com/fusionauth_user/_count?q=data.migrated%3Atrue%0A'
----

[source,json]
.Results of the Elasticsearch migrated user query
----
{"count":629,"_shards":{"total":5,"successful":5,"skipped":0,"failed":0}}
----

However you retrieve the number, compare it to the number of users before the migration began. Recall your finish line estimation and determine if it is time to end the slow migration. 

==== Remove The Proxy

When it is time to end the slow migration, you can remove the Connector policy and optionally the Connector.

image::guides/migration/delete-connector-policy.png[Removing a Connector policy.,width=1200]

==== Deal With The Un-Migrated

At this point, you need to decide how to handle users who haven't been migrated. You considered this situation while planning your migration, but now is the time to implement the decision; you can also adjust it if need be.

Here are some options:

* Notify the users to encourage them to migrate. You can contact them with a message like: "if you don’t log in by DATE, your account will be deleted".
* Archive or delete the accounts and their corresponding data. When a user comes to your site and tries to sign in, they won't have an account and may be forced to re-register. 
* Move them to FusionAuth via a big bang migration. 
* Extend the time running both systems; that is, continue the slow migration.

You can mix and match these approaches. You could migrate all paying customers, event those who haven't signed in during the migration period. At the same time you could archive the data of the free accounts; those potential customers may have been trialing your application in the past and may have forgotten they even have an account.

== Additional Resources

If you have a simple users table and want to walk through how a migration would work with that, review the link:/docs/v1/tech/tutorials/migrate-users/[Migrate Users tutorial].

FusionAuth maintains a https://github.com/FusionAuth/fusionauth-import-scripts[repository of open source import scripts] to help you migrate from third party identity providers.

If you need further assistance migrating to FusionAuth, please ask a question in the https://fusionauth.io/community/forum/[FusionAuth forum, window="_blank"]. If you have a licensed edition you may open a https://account.fusionauth.io[support request from your account, window="_blank"].

TBD add proxy script to fusionauth-import-scripts ?
