---
layout: doc
title: Migration Guide
description: How to migrate your users to FusionAuth.
---
:page-liquid:

== Overview

This guide will help you migrate existing users to FusionAuth. It covers the types of migrations available as well as the phases and activities of a successful migration.

== Types of Migrations

There are three approaches to user data migration. 

* Migrate everyone at once, also known as a "big bang" migration.
* Segment your users and migrate each segment in a series of small bang migrations. 
* Migrate user data each time a user authenticates, also known as "slow migration".

Each of these moves user and associated account data into FusionAuth from one or more systems of record. Each approach has strengths and weaknesses. 

All three are supported by FusionAuth; pick the one which works best for your situation. Let's examine each approach.

=== The Big Bang Migration

With a big bang migration, you are moving all your users in one effort. The exact amount of time varies, but there is a single cutover period. The basic steps are:

* Map user attributes from the old system to the new system (every approach requires this).
* Build a set of migration scripts or programs. 
* Test it well. Determine migration accuracy and duration.
* Plan to modify your applications to point to the new system (every approach requires this).
* When you are ready to migrate, arrange for an adequate period of downtime, then run the migration scripts or programs.
* Flip the system of record for all your users from the old to the new.

This approach has some strengths:

* If you manage your downtime, the migration can have minimal impact on your users. 
* It has a fixed timeframe. When you have completed the migration, you're done and can shut down the original system.
* If you have to decommission the old system by a deadline, perhaps due to an upcoming license renewal or other external factor, you can plan to migrate before then.
* You only have to run two production user auth systems for a short time; typically you'll run the original system after the cutover in case you need to roll back.
* Employees or contractors accessing user data, such as customer service reps, only need to switch their working routines after the migration is performed.

The big bang approach has some challenges as well: 

* It is common to miss issues during testing because this is a one time process. Production systems are often different in subtle ways from testing environments. 
* Any problems with the migration impact many users, since all were migrated.
* The big bang requires you to write code which you'll test intensely, use once and then throw away. 
* The new auth system must be compatible with the old system passwords hashing algorithm for the migration to be transparent. (An alternative is to force all users to reset their password.)

=== Segment by Segment Migration

Segment by segment migration is the second alternative. It can be thought of as a series of "little bang" migrations. Split accounts into segments and migrate each segment. Natural division points could be the type of user, applications used or even recency of login.

Such a segment by segment migration lets you test your processes in production by migrating less critical, or more understanding, sets of users first. The engineering team will be more understanding of migration issues than paying customers, for instance. 

You will probably be able to reuse code between the different segments. In general, this approach decreases risk when compared to the one time big bang migration.

However, this approach is not without its issues:

* You have multiple projects and downtimes to manage, not just one.
* There may be no natural divisions in your user base.
* If most of the users are in one segment, it may not be worth the extra effort. For example, if you have one popular application and a couple nascent apps, the extra time to migrate in phases might not be worth it.
* This will take longer to complete, requiring you to run both systems for longer.
* You'll need to handle the cutover from the old system to the new system. Depending on how you segment your users, this could be complicated and require additional components. For example, if you divide your users by type, you may need a proxy in front of your auth systems to send admin users to the new system and normal users to the old system.

=== Slow Migration

This approach is the logical endpoint of the segment by segment option; each segment is a single user. However, it presents a different set of tradeoffs.

With a slow migration: 

* You set up a connection between the original auth system and FusionAuth.
* You modify your application to point to FusionAuth.
* FusionAuth receives all auth requests, but delegates the first request for each user to the original user management system. 
* The old system returns the information and FusionAuth creates a new user.
* For subsequent authentication requests for this user, FusionAuth is now the system of record.

To implement a slow migration, FusionAuth needs to pass auth credentials to the old system and get user information returned. You also need to modify applications to point to FusionAuth.

A slow migration has the following benefits.

* Since you are only doing a user migration at the time a user authenticates, by definition the blast radius of a mistake is small; it's limited to whoever is logging in or has logged in. 
* You can upgrade your password hash algorithms transparently without requiring anyone to reset their password. FusionAuth supports a link:/docs/v1/tech/reference/password-encryptors/[number of different algorithms] and you can also link:/docs/v1/tech/plugins/writing-a-plugin/[bring your own].
* You don't have to migrate inactive users and can scrub your user base of such accounts.
* You can also use this opportunity to contact inactive users and encourage them to log in.
* There's less downtime during the cutover because you aren't moving any data, simply switching where users authenticate.
* You don't have to understand all the moving pieces of the old auth system. You many need to extend it to add an auth API and you will need to understand the user account attributes. But you don't have to understand all the business logic which goes into authentication. 

However, a slow migration isn't the right solution for every application. Issues to be aware of:

* You are passing a user's plaintext password from FusionAuth to the old auth system. Take special care to secure this data in transit. If possible, avoid it travelling over the internet. 
* The old user management solution must be extensible or support a standard like LDAP.
* You have to run both FusionAuth and the original system for the duration of the migration. Depending on the state of the old system, this may be painful.
* Customer service and other internal users may need to access two systems to find a user during the migration period.
* Rollback from a phased migration is more complex if there are issues, because there are two systems of record, one for users who have been migrated and one for users who have not yet been.

== Migration Implementation

Now that you have an understanding of the different possible approaches, let's look at how to implement each one.

However, before we do so, there are certain common steps to take. The first is getting familiar with FusionAuth's nomenclature. Taking some time to do so will save you time in the end when searching for documentation or writing code against the FusionAuth APIs.

=== FusionAuth Core Concepts

The link:/docs/v1/tech/core-concepts/[Core Concepts section] is worth reviewing to help you plan your migration and future FusionAuth usage. Important FusionAuth concepts are users, applications, roles, groups, registrations and tenants. Here's a short summary of how they relate.

* A tenant is a top level object that contains users, applications and groups, as well as other settings.
* Applications have roles. Users authenticate and are authorized to access applications.
* Groups contain users and may have associated roles. 
* Users have registrations with applications. You can create registrations at the same time you are creating a user.

==== Testing FusionAuth Integration

If you haven't already done so, test to ensure FusionAuth will work with your application. You can link:/docs/v1/tech/5-minute-setup-guide/[install it in about five minutes]. 

A proof of concept will be helpful in determining which link:/docs/v1/tech/core-concepts/integration-points/#login-options[login method] you should use and how to link:/docs/v1/tech/themes/[theme the hosted login pages] to maintain your application's look and feel. 

FusionAuth assigns users roles which are made available via API calls and the JWT sent to client applications after successful authentication. You may need to update your application to look at `roles` claims to allow or disallow functionality in an application.

You may choose to use a library to interface with FusionAuth's standards compliant OAuth and OIDC endpoints. There are link:/docs/v1/tech/example-apps/[sample applications] you can look at to see this integration.  

If you allow users to register with your application, plan to modify your application to point to FusionAuth's registration form and make sure you're capturing the registration data you need.

If you have social sign-on, such as Google, or enterprise identity provider integration, such as SAML, configure and enable those providers as well.

Testing how to integrate FusionAuth with your existing application before diving into the migration planning will ensure that when the time comes to cut over to FusionAuth, you won't have any surprises.

TBD is this too basic?

Next, let's talk about migration planning.

=== Migration Planning and Assessment

The first step to any successful data migration is planning, and user data migration is no different. You need to know:

* Where all your data sources are
* Who uses the data from the source
* If your application can work with a read only version of the system to minimize downtime
* How to connect to each datasource
* What the data looks like 

A full explanation of data migration planning is beyond the scope of this guide. But here are some items to consider when moving user data.

Consider the edge cases. What fields are required and optional in the old auth system (or systems)? FusionAuth requires minimal data about a user; only a password and username or email are required. 

Is there a clean one-to-one mapping between the original system's user data fields and FusionAuth? The answer is usually "no". Therefore you should spend some time examining the current system's data and seeing how it maps. We'll look at an example of a mapping process in the next section. What should you do if you have data which doesn't map cleanly to any of the fields available in FusionAuth? FusionAuth provides a `data` field on a number of entities, including user and application registrations.

Think about how you are going to handle unexpected user data. You can save the entire record off for examination, toss it as malformed, or ignore only the fields that contain unexpected data. Which choice you make depends on the value of each account.

With FusionAuth, you have the option of storing arbitrary key value data in the user or the registration object. You can serialize the old system's user data and store it in the `user.data` field. Having access to the original, unmigrated user data can be helpful in the future. If there was mistranslated data or fields, you'll be able to examine what was present in the old system without accessing it.

Don't forget to handle relationships between users and other identity entities. Groups, application associations, roles, historical data, and anything else from the old system tied to user accounts. Find out where this data is coming from, if it should be migrated, and where it will end up. It might be stored in FusionAuth or a different datastore. 

User migration involves user data, so there are two common field types worth a closer examination. 

The first is user ids. These are often referenced by other systems, including external ones, and may be used for auditing, analytics or other historical purposes. You can preserve these user ids in two ways when moving to FusionAuth.

* If your user ids are FusionAuth compatible UUIDs, specify the user id when you create each user in FusionAuth.
* If your user ids are in some other format, store them in the `user.data` field under a key such as `original_user_id`. You will then be able to search on this value when needed.

The second notable attribute is the password, and related fields such as a salt or hashing scheme. The means of dealing with this data depends on what kind of migration you are performing. For a big bang or segment by segment approach, you'll want to ensure FusionAuth can handle the original system's hashing algorithm. For the slow migration, the migration happens on authentication, so the password will be available for FusionAuth to hash without any extra effort.

If you have user data in multiple systems and are planning to merge the data, don't forget to map the user fields from both old datastores. 

Finally, decide if you are going to pursue a big bang, segment by segment or slow migration strategy, based on the tradeoffs outlined above.

==== An Example of Data Mapping

Let's examine a data mapping example. Suppose an old auth system has a user data model with these attributes and data types:

* `fname` - string
* `lname` - string
* `datebirth` - string
* `phone_num` - string
* `role` - string

FusionAuth has a user object with these attributes and data types:

* `firstName` - string
* `lastName` - string
* `birthDate` - An ISO-8601 formatted date string
* `mobilePhone` - string

There are four mappings that need to occur.

The first is converting from `fname` to `first_name` and `lname` to `last_name`, which might seem trivial. Where this gets difficult is that you need to make sure you do this for each and every field. Spreadsheets are your friend.

The second mapping task is parsing the `datebirth` field into an ISO-8601 formatted string, to be placed in the `birthDate` field. Depending on how clean the original data is, this could be simple or it could be painful. If the latter, use a date parsing library; it'll handle edge cases you haven't thought of.

Then, consider how to handle the `phone_num` field. If you know that every number in your original datastore is a mobile number, you could use the `mobilePhone` FusionAuth field. You could also store it in the `user.data` field; you could store the phone number in `user.data.phoneNumber`, for example.

Finally, you need to map role values. Roles in FusionAuth are stored on the `registration` object, because they are associated with applications and users. When you are creating a user, you can create a registration at the same time.

In general, any data associated with a user but which doesn't change between different applications should be stored on the `User` object. Examples include their name and their phone number. Here's a sample FusionAuth `User` object:

[source,json]
.Example User JSON Request Body
----
include::docs/src/json/users/request.json[]
----

Please consult the link:docs/tech/v1/apis/users/[User API] for thorough field descriptions and documentation. 

Any data that is associated with a user's use of an application, on the other hand, should be stored on the registration object. Examples include their roles or application specific profile data. Here's a sample FusionAuth registration object:

[source,json]
.Example User Registration JSON Request Body
----
include::docs/src/json/user-registrations/create-request.json[]
----

Please consult the link:docs/tech/v1/apis/users/[Registration API] for full documentation.

As this example shows, getting ready for a migration consists of many tiny choices and design decisions. Understanding the data model for your users before you start the migration will prevent unpleasant surprises.

=== Setting Up FusionAuth

Before you can migrate any user information into FusionAuth, you need to ensure it is set up correctly. While you tested it out above, now it is time to set up a production ready instance. 

Determine where your FusionAuth instances should be hosted. You can self host in any data center or cloud provider, or use a managed offering from FusionAuth, link:/pricing/#cloud[FusionAuth Cloud]. 

Decide on whether you need a link:/pricing/#editions[support plan], with guaranteed response times. Evaluate if you need any of the link:/features/reactor/[paid edition features].

Consider your change management strategy. How will you capture your FusionAuth settings so that you can make changes in the future in a measured, understandable way? You can use the https://registry.terraform.io/providers/gpsinsight/fusionauth/latest[community supported Terraform provider] or script changes in your language's link:/docs/v1/tech/client-libraries/[client library]. 

==== Configure FusionAuth

Now you need to prepare FusionAuth for your users and applications. While exact configurations depend on your use cases, in general you'll want to look at the following. All of this configuration can be done via the API or the administrative user interface. If you want to use the former, you'll have to link:/docs/v1/tech/apis/authentication/#manage-api-keys[create an API key].

Optionally create one or more tenants. Multiple tenants are useful for allowing a user to have the same email but different passwords, or allowing applications to have different settings such as theme or password rules. You'd add these via the API or navigating to [breadcrumb]#Tenants#.

Create one or many applications and add any roles needed for them. Create a FusionAuth application for each application whose users you are migrating. An application is anything a user can log in to, whether an API, a commercial product, or a custom single page application. Add these via the API or navigating to [breadcrumb]#Applications# in the administrative user interface. 

image::guides/migration/add-application.png[Adding an application.,width=1200,role=bottom-cropped]

Map user attributes, as covered above, into FusionAuth `user` or `registration` objects. If it doesn't fit into the FusionAuth schema, add it to the appropriate `data` field.

Now that FusionAuth is up and running, proceed to either the <<Big Bang Implementation>>, the <<Segment By Segment Implementation>> or the <<Slow Migration Implementation>> section.

=== Big Bang Implementation

Below, find out how to migrate all your user data into FusionAuth at one time.

==== Performance

Because you have downtime with this approach, you're going to want to import users as fast as possible. Tweak these FusionAuth settings and perform the following tasks to do so.

link:/docs/v1/tech/tutorials/switch-search-engines/[Switch to the database search engine]. FusionAuth won't have to sync user data to Elasticsearch during the import, which will speed it up. If you require Elasticsearch for advanced searching capabilities, switch back to that search engine after the migration is complete.

Disable the `user.bulk.create` webhook unless you need FusionAuth to send an event with all the created users' somewhere.

Ensure you are setting the HTTP timeout very long on your API requests. Configure whatever tool you're using to make the HTTP request. The import API is a synchronous operation, though there are plans to make it asynchronous (see https://github.com/FusionAuth/fusionauth-issues/issues/944[this GitHub issue for more]).

If you only provide a `password` field, then FusionAuth will assume the password is in plaintext and hash it for you; doing so negatively affects load time, performance and throughput. If you provide the `salt`, `password`, `encryptionScheme` and `factor` then we will assume the value in the `password` field is a hashed password, and it will not be hashed. 

If possible, stage your data by exporting current user data into JSON files. This will make debugging easier, since you can load one file at a time, and you can repeat loading files if there are issues. It will also be more performant than loading data across a network or from a database.

[NOTE]
====
The easiest and fastest way to load bulk user data into FusionAuth is to loop over a directory of JSON files that each contain 100,000 users. These JSON files should be clean, have no collisions and be minified. 

In FusionAuth testing, this approach resulted in loading 100,000 users in 108 seconds, though performance is dependent on hardware, network and database constraints as well.
====

==== Building the Migration Scripts

To actually move the data, you'll build out a series of scripts and programs. To begin this process, stand up a FusionAuth instance to test out the migration process. To start your FusionAuth instance in a known state every time, you may want to configure link:/docs/v1/tech/installation-guide/kickstart[Kickstart]. This file can also serve as a foundation for developers and CI processes in the future.

You'll also want to link:/docs/v1/tech/apis/authentication/#manage-api-keys[create an API key]. Make sure you give it appropriate permissions. The minimal permissions required is the `POST` method on the `/api/user/import` endpoint.

image::guides/migration/api-key-creation.png[Adding an application.,width=1200]

You can write the scripts in shell, any of the supported link:docs/v1/tech/client-libraries/[client library languages], or against the link:docs/tech/v1/apis/users/[REST API] in any language which can make HTTP calls. Iterate over all the users in the old system or systems. Build the JSON files and then call the bulk import API. Add a registration for each application to which a user should have access. 

[NOTE]
====
Make sure you create all your groups, tenants and applications before you import your users.
====

If you can't build JSON files, you can also build the JSON in memory. This can be a good approach if you are dynamically merging two data sources, but will be tougher to troubleshoot.

You can import the JSON using the `importUsers` method of a FusionAuth client library or by calling the REST API directly. 

Here's an example of an import JSON request body. This example imports one user, but you can add multiple `user` objects to the `users` array:

[source,json]
.Example User Import JSON Request Body
----
include::docs/src/json/users/import-request.json[]
----

Here's an example of a curl script to import the file. It times out in 10 minutes, iterates over JSON files in a directory, and bails out if it doesn't receive a `200` response:

[source,shell]
.Example User Import Shell Script
----
#!/bin/sh

API_KEY=...
JSON_FILE_DIR=...
FA_HOST=...

for file in $JSON_FILE_DIR/*.json; do
  echo "Processing $file";
  RES=`curl --max-time 600 \
       -s -w "%{http_code}" \
       -H "Authorization: $API_KEY" \
       -H "Content-type: application/json" \
       -XPOST \
       $FA_HOST/api/user/import \
       -d@$file`
  if [ "$RES" -ne "200" ]; then
    echo "Error: $RES";
    exit 1;
  fi
done
----

Consult the link:/docs/v1/tech/apis/users/#import-users[documentation for this API] for more information. 

If the original system hashes passwords using an algorithm other than those link:/docs/v1/tech/reference/password-encryptors/[schemes FusionAuth supports], write and install a link:/docs/v1/tech/plugins/password-encryptors/[custom password hashing plugin]. In either case, specify the scheme in the import JSON. 

Duplicate user emails are not allowed within the same tenant. If you may have duplicate emails, de-duplicate before importing. If you don't want to do so, set the `validateDbConstraints` property to `true` in the import JSON. When this is set, the import API will return a user friendly error message when duplicate addresses are sent. 

[source,json]
.Import Error Message When validateDbConstraints is true
----
{
  "fieldErrors": {
    "user.email": [{
      "code": "[duplicate]user.email",
      "message": "A User with email [example@piedpiper.com] already exists."
    }]
  }
}
----

[source,json]
.Import Error Message When validateDbConstraints is false
----
{
  "generalErrors": [{
    "code": "[ImportRequestFailed]",
    "message": "An error occurred during the import request. This is most likely due to a unique key constraint which would indicate one or more of the users in the import request already exist in FusionAuth. Re-attempt the request with additional validation by using the [validateDbConstraints] property. If you have already enabled the additional validation and you still receive this error, please open a bug report."
  }]
}
----

This comes at a performance cost, however, so one strategy is to run your import with `validateDbConstraints` equal to `true` to find the duplicate email addresses and remove or remediate them. After that, you can run an import with `validateDbConstraints` equal to `false`.

Next, determine if you need to import refresh tokens. If you are using an existing system which presents such tokens to the identity provider when an existing JWT expires, importing refresh tokens ensures that your users enjoy an uninterrupted experience. 

Consult the link:/docs/v1/tech/apis/users/#import-refresh-tokens[documentation for this API] for more information.

==== Testing

Test this import process with as large of a dataset as possible. If you can, use your entire user dataset. Doing so tells you how long your import will take and also will shake out edge cases, such as duplicate emails or incorrectly formatted user attributes.

Even if you aren't using multiple tenants in production, during this testing phase it is a good idea to create a `Testing` tenant and load all your users and applications into this tenant. 

You can drop a tenant with one API call or click in the administrative user interface. When you do, all the users, applications, groups and settings of that tenant will be removed, making it easy to iterate. 

You cannot drop the `Default` tenant containing the FusionAuth application, which is why you must create a new tenant. You could also drop the entire database and do a fresh FusionAuth install each time you want to test an import.

==== Performing the Migration

When your scripts work in your testbed environment, prepare to do a production migration. Inform all the internal stakeholders. Plan for downtime unless you can run your application with the original user store in a read only mode. How much downtime? You should know based on your testing of the import.

Run the migration on your production dataset, moving the data from the original system to FusionAuth.

When the migration is finished, release your application changes. You should now point to FusionAuth for all authentication requests, including, but not limited to: 

* Log in 
* Registration, if applicable
* Forgot password
* Password changes

Should you need to rollback, revert the changes to your application pointing it to FusionAuth. If users updated profile data in FusionAuth, you'll need to port those changes back to your legacy system. A script using the User API will be a good starting point.

=== Segment By Segment Implementation

A segment by segment migration is similar to the above, except that you are going to split your user data into segments and migrate each segment.

However, the application cutover process is not as simple as in the big bang approach. You can't simply send all your users to FusionAuth when you haven't migrated all of them. 

Which users you send to FusionAuth depend on how you created your segment. If, for instance, you split on application usage, then it should be easy to update one application to send authenticating users to FusionAuth. If you split your user base on other attributes, you'll need to build logic in your application to determine where to send a user when they log in.

=== Slow Migration Implementation

With FusionAuth, slow migrations are done with link:docs/v1/tech/connectors/[Connectors]. 

*This feature is available in all paid editions of FusionAuth. Please visit link:/pricing/[our pricing page] to learn more about paid editions.*

==== Determine Your Finish Line

Unlike a big bang migration, with a slow migration you need to set a migration completion goal. Slow migrations move users one at a time, so it is unlikely you'll migrate one hundred percent of your users. Some people log in to your application rarely while others may have abandoned their account. No matter how long a migration period you allow, some of your users will not log in, and won't be migrated.

So, with this approach, you need to decide what "done" means. Consider the following when making this determination:

* How often do people log in? 
* Is there a significant long tail of users who visit the application less frequently than the average user?
* Are there external events such as times of the year or holidays when greater or lesser numbers of users authenticate? 
* What are the ramifications of a user being unable to log in? Are there business, compliance, legal, or security concerns? Is loss of timely access to your application an annoyance or a disaster?
* You will have some users who are not migrated. What will you do with them after the migration is done?
* How painful is it to operate both FusionAuth and your current authentication system?
* How valuable is a customer who has not logged in to your application in six months? A year? Three years? 

Set a goal for a number or percent of migrated users, the duration of the migration period, or both. Otherwise you don't know when to stop the migration. Set a cadence for how often you'll check the number of users migrated and compare it with your goal.

Make sure you can regularly query FusionAuth to know the number of migrated accounts. To do so, set a value on the `user.data` object, such as `user.data.migrated`, indicating successful migration. You'll also need to ensure you are using the Elasticsearch search engine, but link:/docs/v1/tech/tutorials/switch-search-engines/[you can switch easily].

==== Migration Timeline

You also want to communicate a timeline for migration. You can calculate that by knowing the following:

* How frequently the average user logs in.
* What the distribution of your users' login behavior is.
* What your migration goal is.

Determining these values precisely is beyond the scope of this guide. However, a good rule of thumb is to determine how often your average user logs in to your application. Then you can use this formula to find out when a certain percentage of users have migrated: `S = [(1 - (1 - P)^D)*100]%`

* `P` is the probability of any single user authenticating in a given day. So if your users login once a week on a business day, it is 0.2 (one out of five days). If they login once a year, it is 0.0027 (one out of 365 days).
* `D` is the number of days of the migration period.
* `S` is the percentage of users who have migrated.

For `P = 0.2` and `D = 10`, `S = 89%`. If your users log in one out of every five days, in ten days almost nine out of ten will be in FusionAuth.

For `P = 0.0027` and `D = 370`, `S = 63.7%`. If your users log in once a year on average, in about a year, almost two thirds of accounts will be migrated to FusionAuth.

Using the above calculations should help you determine how long of a migration period to plan for.

==== Connect To The Original System

With slow migration, FusionAuth is connecting to your previous datastore every time a user not currently in FusionAuth authenticates. This connection is either an HTTP API or an LDAP call. 

If your current user datastore is an LDAP directory, then you don't need to do anything special to connect; FusionAuth knows how to communicate with LDAP servers already.

If, on the other hand, your datastore is not LDAP, you'll need to build an HTTP API and use a Generic Connector. This API must take a login request in JSON format and authenticate the user:

[source,json]
.Example Migrate on Authentication Login Request JSON
----
include::docs/src/json/login/request.json[]
----

It should return a FusionAuth login response, which includes the `User` object as well as a JWT:

[source,json]
.Example Successful Login Response JSON
----
include::docs/src/json/users/login-migrated-response.json[]
----

The generated JWT will be delivered to the client to present to any resource servers (other API servers, etc). For maximum compatibility, it should have link:/docs/v1/tech/apis/jwt/[FusionAuth claim values]. TBD is this so?

The response above sets the value of `user.data.migrated` to `true`, to indicate that this user has been migrated. This allows you to query migration progress as mentioned above. You can read more about the link:/docs/v1/tech/connectors/generic-connector/[Generic Connector requirements] in the documentation.

==== Configure Your Connector

Navigate to [breadcrumb]#Settings -> Connectors# and add a Connector. You can also configure Connectors by using the API; consult the link:/docs/v1/tech/apis/connectors[Connector API documentation] for more details.

image::guides/migration/add-connector.png[Adding a Connector.,width=1200]

Configuration varies depending on whether the original datasource is an HTTP API or an LDAP directory.

===== LDAP

Configure the connection information, including the URL of the server, the method used to connect to it (LDAPS, STARTTLS), and a system account which can query across all accounts for the directory or section of the directory tree being migrated. You'll also need to specify user attributes to be queried and returned.

Map each attribute from the LDAP directory into the FusionAuth user object. You do this with an link:/docs/v1/tech/lambdas/ldap-connector-reconcile/[LDAP Connector Reconcile Lambda]. 

[source,javascript]
.An Example LDAP Connector Reconcile Lambda
----
include::docs/src/lambda/ldap-connector-reconcile.js[]
----

Make sure you uncomment the lines where `user.data.migrated` is set to `true`, as that will be needed for the migration progress query. More details about configuration are available in the link:/docs/v1/tech/connectors/ldap-connector/[LDAP Connector documentation].

===== Generic

With a Generic Connector, configure the end URL and the security settings. The mapping of the original system's user data into FusionAuth is taken care of when you built the API.

Make sure you use TLS to connect to this endpoint, since you'll be sending sensitive user information. Full configuration details are available in the link:/docs/v1/tech/connectors/generic-connector/[Generic Connector documentation].

==== Capturing Migration Progress

As mentioned above, you want to make sure you can identify that a user has been migrated, rather than signed up for or created directly in FusionAuth. This is necessary to allow you to determine progress toward your migration goal.

Ensure that every migrated user has a `user.data.migrated` attribute set to `true`. Whichever connection you use, make sure you set this attribute, as illustrated above.

==== Testing

To test this, log some users in. If you have test users in your original auth system, you can use the link:/docs/v1/tech/apis/login[Login API] to automate the testing:

* Confirm they are not in FusionAuth
* Log a user in
* Confirm they are in FusionAuth

==== Proxying Authentication

With FusionAuth, proxying authentication requests to the original datasource is easy. You've already set up the connection information when configuring the Connector. Now associate the Connector to the tenant. This is called a Connector policy. Navigate to [breadcrumb]#Tenants -> Connectors# and add a policy.

image::guides/migration/add-connector-policy.png[Adding a Connector policy.,width=1200]

Make sure to check the [field]#Migrate user# checkbox. Then, each user will be authenticated against the original user datastore the first time they are seen. Their data will be migrated to FusionAuth. On subsequent authentications, they'll be authenticated with FusionAuth. You can learn more about configuring Connector policies in the link:/docs/v1/tech/connectors/[Connector documentation].

==== Modify Your Application 

Unlike the big bang, there is no protracted downtime. You simply need to release the changes required for users to authenticate against FusionAuth. Make sure you record the number of accounts in the old system just before cutover.

Should you need to rollback, revert the changes to your application pointing it to FusionAuth. If users updated profile data in FusionAuth, you'll need to port those changes back to your original system. A script using the User API will be a good starting point.

After you release this modified version of your application, your users will begin their transparent migration into FusionAuth. 

==== Monitor Progress

You can monitor your progress by comparing the number of users who have been migrated successfully with the number of users in the original auth system. To query FusionAuth, run this shell script:

[source,shell]
.Shell script to count the number of migrated users
----
API_KEY=...

curl -H "Authorization: $API_KEY" 'http://localhost:9011/api/user/search?queryString=data.migrated%3Atrue%0A'
----

This will return all the users who've been migrated as well as a count, subject to the limits of FusionAuth's Elasticsearch integration. See this https://github.com/FusionAuth/fusionauth-issues/issues/494[GitHub issue] for more on those limits. Here's an example of the output:

[source,json]
.Results of the FusionAuth migrated user query
----
{"total":629,"users": [ ... ] }
----

If you are migrating more than 10,000 users, query Elasticsearch directly to retrieve the count:

[source,shell]
.Shell script to count the number of migrated users directly against Elasticsearch
----
curl 'https://elasticsearch.piedpiper.com/fusionauth_user/_count?q=data.migrated%3Atrue%0A'
----

[source,json]
.Results of the Elasticsearch migrated user query
----
{"count":62900,"_shards":{"total":5,"successful":5,"skipped":0,"failed":0}}
----

However you retrieve the number of users migrated, remember to regularly compare it to the number of accounts in the original system before the migration began. This will help you determine if it is time to end the slow migration. 

==== Remove The Proxy

When it is time to stop the slow migration, remove the Connector policy. You may also optionally remove the Connector.

image::guides/migration/delete-connector-policy.png[Removing a Connector policy.,width=1200]

==== Handle Unmigrated Users

At this point, decide how to handle users who haven't been migrated. You may be able to find these users by subtracting the users who have been migrated from the users in the original system. You may also be able to query the original system directly and note who has not signed in since the slow migration started.

You considered this situation while planning your migration, but now, implement the decision. Here are some options:

* Notify them and encourage them to log in. You can contact them with a message like: "if you don’t log in by DATE, your account will be deleted".
* Archive or delete the accounts and their corresponding data. When a user comes to your site and tries to sign in, they won't have an account and will be forced to re-register, having lost their data. 
* Move them to FusionAuth via a big bang migration. 
* Extend the time running both systems; that is, continue the slow migration.

You can mix and match these approaches. For example, you could migrate all paying customers, even those who haven't signed in during the migration period. At the same time you could archive the data of the free accounts; those potential customers may have been trialing your application and may have forgotten they have an account.

== Additional Resources

If you have a single users table and want to walk through how a migration would work with that, review the link:/docs/v1/tech/tutorials/migrate-users/[Migrate Users tutorial].

FusionAuth maintains a https://github.com/FusionAuth/fusionauth-import-scripts[repository of open source import scripts] to help you migrate from third party identity providers.

If you need further assistance migrating to FusionAuth, please ask a question in the https://fusionauth.io/community/forum/[FusionAuth forum, window="_blank"].

If you have a paid edition you may open a https://account.fusionauth.io[support request from your account, window="_blank"].


TBD split apart?
TBD canarying?
TBD limitation one identifier per user (email, ec
