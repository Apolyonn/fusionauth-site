---
layout: blog-post
title: Securing A Golang App with OAuth
description: Golang lets you build web applications that are performant and easy to deploy. This tutorial will show you how to use OAuth to authenticate users in a golang application.
author: Krissanawat Kaewsanmuang
image: blogs/react-native-oauth/securing-react-native-with-oauth.png
category: blog
tags: client-golang
excerpt_separator: "<!--more-->"
---

In this tutorial, we are going to learn how to secure a golang program with OAuth while using FusionAuth as an auth provider. Authentication and authorization are essential for any application, and golang apps are no different. 

<!--more-->

First, we will set up the FusionAuth server. Then, we'll configure the golang program to construct a URL to direct a user to a login form, generated by FusionAuth. Lastly, we will learn how to make use of an access token in order to get user data using OIDC. 

You can follow along conceptually, or check out the [GitHub repo](TBD) with the complete implementation first. Now, letâ€™s get started!

## Requirements

The requirements to follow this tutorial are as follows:

* Go SDK
* VScode or any other text editor
* FusionAuth
* git for version control
* Homebrew (optional)

## Setting up FusionAuth as your auth provider

FusionAuth lets you [pick your installation method](/docs/v1/tech/installation-guide/). However, in this post, we'll be on macOS using Homebrew. The process is simple. First, we are going to install the tap by running the following command in the terminal:

```shell
brew tap fusionauth/homebrew-fusionauth
```

Note that this installation step only needs to be done once. Next, we need to install the FusionAuth main service by running the following command:

```shell
brew install fusionauth-app
```

Lastly, we need to start the FusionAuth service by running this in the project terminal:

```shell
brew services start fusionauth-app
```

In order to get started, we need to open our browser and go to `http://localhost:9011`. Then, we need to complete the maintenance mode and the setup wizard.

### Setup FusionAuth with the installation wizard

We will see the maintenance mode form that requires a super user credential for your database:

{% include _image.liquid src="/assets/img/blogs/golang-oauth/maintenance-mode-database.png" alt="The FusionAuth maintenance mode screen, including the super user configuration." class="img-fluid" figure=false %}

It will use this to create a database user for FusionAuth to connect to, as specified further down the maintenance mode page:

{% include _image.liquid src="/assets/img/blogs/golang-oauth/maintenance-mode-database-lower.png" alt="Adding a user for FusionAuth to connect as." class="img-fluid" figure=false %}

If you want to create a FusionAuth user and database using your own tools, rather than maintenance mode, you can. See the [silent mode documentation](/docs/v1/tech/guides/silent-mode) for more on this.

Once you've created a database for FusionAuth, you'll need to accept the license and create an initial FusionAuth user:

{% include _image.liquid src="/assets/img/blogs/golang-oauth/setup-wizard.png" alt="The FusionAuth setup wizard." class="img-fluid" figure=false %}

Then you'll need to log in to your new FusionAuth account. This user has administrative privileges within the FusionAuth instance:

{% include _image.liquid src="/assets/img/blogs/golang-oauth/login-admin-screen.png" alt="Logging in to the FusionAuth administrative user interface." class="img-fluid" figure=false %}

### Create and configure a new Application

Initially, there will be only one application: FusionAuth itself. Hence, we need to create a new application by navigating to the "Applications" tab and clicking the green "+" sign. 

Then, we need to configure this application. First, add the authorized callback of `http://localhost:8080/callback`. This is the URL which will process the authorization code should a user authenticate successfully. 

In addition, make sure that the Authorization Code checkbox is already checked and enabled. This is the grant we'll be using, and the one that is recommended for most use cases. 

After a successful setup, we will see the endpoint details as shown in the screenshot below:

{% include _image.liquid src="/assets/img/blogs/golang-oauth/oauth-configuration.png" alt="The application configuration screen." class="img-fluid" figure=false %}

We set up this application in the default tenant. FusionAuth supports multi-tenant configurations, but for this post, we'll keep all user data in one tenant, as that makes things slightly simpler. Now, our FusionAuth setup is complete. Let's move to the golang part.

## Setting up the development environment for Go

We are going to set up a development environment for the Go ecosystem. First, we need to download Go from its official website as shown in the screenshot below:

pic tbd

Then, we need to create a new project folder in VScode. Inside the project, we need to create a new file named `main.go`:

pic TBD

Let's walk before we run. First, run the simplest Go project; not surprisingly this is the typical 'Hello World' program. This is what it looks like:

```go
package main
import "fmt"
func main() {
  fmt.Println("Hello, Golang")
}
```

In the terminal, in the directory where this code is, run:

```shell
go run main.go
```

We get the following result:

pic tbd

Success! Let's add in some authentication, shall we?

## Initial handlers and OAuth2 config

We are going to set up the handlers and OAuth2 configuration. For that, we need to import necessary components such as the OAuth and HTTP packages first:

```go
package main
import (
  "fmt"
  "io/ioutil"
  "net/http"
  "golang.org/x/oauth2"
  "github.com/thanhpk/randstr"
)
//...
```

Then, we need to define a variable to contain the configurations as shown in the code snippet below:

```go
//...
var (
  FusionAuthConfig *oauth2.Config
  oauthStateString = randstr.Hex(16)
)
//...
```

Next, we need to create a new OAuth instance and configure it in the init function. Here, we only need `ClientID`, which we got from the FusionAuth application OAuth config section. We also need to define the OAuth2 endpoints (which we can pull from the [FusionAuth docs](/docs/v1/tech/oauth/endpoints)) and a callback URL (as entered in the FusionAuth config above):

```go
//...
func init() {
  FusionAuthConfig = &oauth2.Config{
    RedirectURL: "http://localhost:8080/callback",
    ClientID:    "7d2b4cb4-ccd5-42ac-8469-f802393c8f98",
    Scopes:      []string{"openid"},
    Endpoint: oauth2.Endpoint{
      AuthURL:  "http://localhost:9011/oauth2/authorize",
      TokenURL: "http://localhost:9011/oauth2/token",
    },
  }
}
//...
```

Here, we have defined the OAuth instance inside the `init` function. This function is called and run every time the application is started. In a production application, these values may be pulled from a configuration file or a database table.

## Adding our display

Now, we need to display a page. For the `handleMain` function, we are hard coding HTML as shown below, but for a larger application you might want to look at a templating language: 

```go
//...
func handleMain(w http.ResponseWriter, r *http.Request) {
  var htmlIndex = `<html>
    <body>
       <a href="/login">FusionAuth Log In</a>
    </body>
    </html>`
   fmt.Fprintf(w, htmlIndex)
}
//...
```

Then, we need to call the `handleMain` function inside the `main` function. This lets us listen to port 8080:

```
//...
func main() {
  http.HandleFunc("/", handleMain)
  fmt.Println(http.ListenAndServe(":8080", nil))
}
//...
```

Since we changed the code from the "Hello world" example, we need to restart the golang program. We need to stop the existing server. And then we need to restart it by using this command:

```shell
go run main.go
```

Navigate to `http://localhost:8080/`. We will get the following screen in the web browser:

pic TBD

Great, but how do we actually log in? Glad you asked.

## Login function

For the login function, we need to create a new function called `handleFusionAuthLogin`. Then, we generate a URL and use the HTTP package to redirect the user to it. Because we are using a properly configured OAuth library, the URL is generated for us. 

```go
//...
func handleFusionAuthLogin(w http.ResponseWriter, r *http.Request) {
  url := FusionAuthConfig.AuthCodeURL(oauthStateString)
  http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}
//...
```

## Handling the callback

In order to handle the callback, which will contain the `code` parameter and is crucial to the Authorization Code grant, we pass the temporary `code` and `state` variables to a `getUserInfo` function. We'll see the code behind that function below, but it is going to get user data back from FusionAuth. The code to handle the callback is:

```go
//...
func handleFusionAuthCallback(w http.ResponseWriter, r *http.Request) {
  content, err := getUserInfo(r.FormValue("state"), r.FormValue("code"))
  if err != nil {
    fmt.Println(err.Error())
    http.Redirect(w, r, "/", http.StatusTemporaryRedirect)
    return
  }
  fmt.Fprintf(w, "Content: %s\n", content)
}
//...
```

We'll also need to update our main function to ensure the above two handlers are registered at a path accessible to the browser:

```golang
func main() {
  http.HandleFunc("/", handleMain)
  http.HandleFunc("/login", handleFusionAuthLogin)
  http.HandleFunc("/callback", handleFusionAuthCallback)
  fmt.Println(http.ListenAndServe(":8080", nil))
}
```

## Display the user data

In order to fetch and display user info, we need to create the `getUserInfo` function, as promised above.

```go
//...
func getUserInfo(state string, code string) ([]byte, error) {
  if state != oauthStateString {
    return nil, fmt.Errorf("invalid oauth state")
  }
  token, err := FusionAuthConfig.Exchange(oauth2.NoContext, code)
  if err != nil {
    return nil, fmt.Errorf("code exchange failed: %s", err.Error())
  }
  url := "http://localhost:9011/oauth2/userinfo"
  var bearer = "Bearer " + token.AccessToken
  req, err := http.NewRequest("GET", url, nil)
  req.Header.Add("Authorization", bearer)
  client := &http.Client{}
  response, err := client.Do(req)
  if err != nil {
    return nil, fmt.Errorf("failed getting user info: %s", err.Error())
  }
  defer response.Body.Close()
  contents, err := ioutil.ReadAll(response.Body)
  if err != nil {
   return nil, fmt.Errorf("failed reading response body: %s", err.Error())
  }
  return contents, nil
}
//...
```

That's a fair bit of code, let's break it down:

* First, we check the `state` parameter received from the server matches what we sent. This is to prevent CSRF attacks.
* Then, we exchange the `code` parameter and retrieve an access token.
* Next, we construct a request to a well known user information endpoint with an `Authorization` header, using the access token as a bearer token.
* Last, we print the response from the server.

We will get the result as displayed in the video below:

https://www.youtube.com/watch?v=uqlD5vopAr8


## Next steps

Obviously you'd want to do more than just print out a JSON data structure in a real application. You'd want to show the user's data, welcome them, and/or show or hide functionality based on who they were. 

You could also make requests to other APIs, presenting the access retrieved after the user signed in as the credentials for access.

## Conclusion

Using the Authorization Code grant in golang lets you use any OAuth compatible identity provider to secure your application. You can review and fork the application on [GitHub](TBD).

Happy coding!

